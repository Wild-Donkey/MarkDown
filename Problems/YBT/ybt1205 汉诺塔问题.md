# ybt1205 汉诺塔问题

## 寒假不断更计划！

### 【题目描述】

约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到中间的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。

这是一个著名的问题，几乎所有的教材上都有这个问题。由于条件是一次只能移动一个盘，且不允许大盘放在小盘上面，所以64个盘的移动次数是：18,446,744,073,709,551,615

这是一个天文数字，若每一微秒可能计算(并不输出)一次移动，那么也需要几乎一百万年。我们仅能找出问题的解决方法并解决较小N值时的汉诺塔，但很难用计算机解决64层的汉诺塔。

假定圆盘从小到大编号为1, 2, ...

### 【输入】

输入为一个整数(小于20）后面跟三个单字符字符串。

整数为盘子的数目，后三个字符表示三个杆子的编号。

### 【输出】

输出每一步移动盘子的记录。一次移动一行。

每次移动的记录为例如 a->3->b 的形式，即把编号为3的盘子从a杆移至b杆。

### 【输入样例】

```
2 a b c
```
### 【输出样例】
```
a->1->c a->2->b c->1->b
```

### 【题解】

#### 首先先高兴一波，我ybt题库排名20000-了！（菜鸡自嗨）

说实在，这道题一开始贾大佬（[她的博客](https://www.cnblogs.com/ZhengkunJia)）（当然，里面没有辣鸡汉诺塔）讲的时候我是连标程都没看懂，后来才大彻大悟的。

规则上面已经说了，接下来是解题的思路，先从真正玩这个游戏的策略入手：

我们既然要将所有圆盘都移走，那么就要将最大的圆盘上面的先移到另外一个柱子上，然后再将最大圆盘移到目标盘子，最后再将剩下的盘子移到移动完毕的最大盘子。

这样我们就可以将原问题分解为三部分，把最大的盘子成为底盘，其余盘子称为尖顶。

下面有请：全网最火毁灭哥来介绍利用hanoi塔毁灭世界的方法：

> ## 毁灭世界有三步
>
> Step1：拿走尖顶
>
> Step2：移动底盘
>
> Step3：把尖顶放回去
>
> 怎么样，是不是很简单，小伙伴们赶紧回家毁灭一下试试吧！

不过话虽这么说，但是就算是用计算机（学校机房的标压奔腾），一秒钟只能算出移动30个圆盘的移动（不输出），所以这里只讨论n<20时的情况

前面说过，如果有n个圆盘，那么问题就成了将n-1个圆盘拿走，移动第n个圆盘，再将n-1个圆盘放回的情况。递归边界就是只拿走一个的情况，此时只要把要移动的圆盘直接拿到目标杆子上即可。这样就可以写出递归函数：

```c++
void hanoi(int n,char A,char B,char C)//这里的A为起始杆，B为目标杆，C为终点杆
{
    if (n==1)
    {
        printf("%c->%d->%c\n",A,n,B);//直接拿过去，不跟他多bibi
        return;//递归边界
    }
    hanoi(n-1,A,C,B);//将n-1个盘子从A移到C(给大佬(本次最大圆盘)让道加让座)
    printf("%c->%d->%c\n",A,n,B);//本次操作的核心：将本次最大圆盘直接移至目标杆
    hanoi(n-1,C,B,A);//将n-1个盘子从C移回到B(移动完的最大圆盘所在地)
    return;
}
```

接下来是~~供你们直接复制的~~完整代码：

```c++
#include <iostream>
#include <cstdio>
using namespace std;
void hanoi(int n,char A,char B,char C)
{
    if (n==1)
    {
        printf("%c->%d->%c\n",A,n,B);
        return;
    }
    hanoi(n-1,A,C,B);
    printf("%c->%d->%c\n",A,n,B);
    hanoi(n-1,C,B,A);
    return;
}
int main()
{
    char A,B,C;
    int n;
    cin>>n>>A>>B>>C;
    hanoi(n,A,B,C);
    return 0;
}
```

### ~~真好，又水了一篇博文~~