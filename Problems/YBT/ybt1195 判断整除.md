# ybt1195 判断整除

【题目描述】

一个给定的正整数序列，在每个数之前都插入+号或−号后计算它们的和。比如序列：1、2、4共有8种可能的序列：

```c++
(+1) + (+2) + (+4) = 7
(+1) + (+2) + (-4) = -1
(+1) + (-2) + (+4) = 3
(+1) + (-2) + (-4) = -5
(-1) + (+2) + (+4) = 5
(-1) + (+2) + (-4) = -3
(-1) + (-2) + (+4) = 1
(-1) + (-2) + (-4) = -7
```
所有结果中至少有一个可被整数k整除，我们则称此正整数序列可被k整除。例如上述序列可以被3、5、7整除，而不能被2、4、6、8……整除。注意：0、−3、−6、−9……都可以认为是3的倍数。

### 【输入】

输入的第一行包含两个数：N(2<N<10000)和k(2<k<100)，其中N代表一共有N个数，k代表被除数。第二行给出序列中的N个整数，这些整数的取值范围都0到10000之间（可能重复）。

### 【输出】

如果此正整数序列可被kk整除，则输出YES，否则输出NO。（注意：都是大写字母）

###【输入样例】
```c++
3 2 
1 2 4 
```
###【输出样例】
```c++
NO
```

### 【题解】

首先，先看题干中的例子，可以看出，组合后的结果的符号与整除于否无关，所以就不用考虑一半的情况。

再者，序列中的数字，能影响答案的，并不是整个数，而是它模k的值罢了，所以对数据进行处理，缩小数据。

```c++
	for(int i=1;i<=n;i++) {
		cin>>tmp;
		tmp%=k;//预处理
		a[i]=tmp;
	}
```

接下来，就到了简化问题的时间

由1,2,4来分析，如果从1开始加入序列，那么1可以被1整除

接下来2加入，这样就有1和3(结果只取绝对值)两个数可以整除

再接下来是4，这样子1,3,5,7就都符合整除规则了。

所以我们就想到~~（题解就说道）~~

可以从头开始，一个一个来（让元素入列）

因为元素越多，组合方式是以指数级爆炸的，又因为如此多的组合的结果有大量重复，所以说就想到~~（题解说）~~可以以k为数组的第二维，只要枚举余数，就可以将复杂度控制到可控范围。

那么，就可以用bool变量f~i,j~表示前i个数是否可以被j整除（1可以，0不可以）

如果要转移到f~i,j~的状态，那么就要在前i-1个数已经入列的基础上再加第i个数，而第i个数又只有正和负两种情况所以便只考虑是由加第i个数和减第i个数就好了。

要想加a~i~得到余数为j的情况，那么前i-1个数必须满足余数可以为j-a~i~

反之，若减a~i~得到余数可以为j，那么前i-1个数必须满足余数可以为j+a~i~

所以，要想a~i~入列后，余数为j，那么上述两个条件满足一个就好。

## 列出方程：f~i,j~=f~i-1,j-ai~||f~i-1,j+ai~

(不过为了防止爆数组，要控制j+-a~i~的数据在k的范围内，所以要+k然后%k)

边界条件：f~0,0~=1(0个元素，结果为零，所以不管k为多少，余数都为零)

所以说，程序打出来是这样的：

```c++
#include<iostream>
#include<cstring>
using namespace std;
int a[10005],n,k,tmp;
bool f[10005][105];
int main() {
	cin>>n>>k;
	memset(a,0,sizeof(a));
	for(int i=1;i<=n;i++) {
		cin>>tmp;
		tmp%=k;
		a[i]=tmp;
	}
	f[0][0]=1;//边界
	for(int i=1;i<=n;i++) {
		for(int j=0;j<k;j++){
			f[i][j]=(f[i-1][(j-a[i]+k)%k]||f[i-1][(j+a[i]+k)%k]);//递推
		}
	}
	if(f[n][0]){
		cout<<"YES"<<endl;
	}
	else{
		cout<<"NO"<<endl;
	}
	return 0;
}
```

Ps:因为本题转移时调用的数组的第二维较为随机，所以就~~不会~~懒得滚动数组了······

感谢[题解](https://blog.csdn.net/m0_37579232/article/details/84994449)