# ybt1217 棋盘问题

### 【题目描述】

在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。

### 【输入】

输入含有多组测试数据。

每组数据的第一行是两个正整数n,k，用一个空格隔开，表示了将在一个n×n的矩阵内描述棋盘，以及摆放棋子的数目。(n≤8,k≤n)

当为−1−1时表示输入结束。

随后的n行描述了棋盘的形状：每行有n个字符，其中#表示棋盘区域，.. 表示空白区域（数据保证不出现多余的空白行或者空白列）。

### 【输出】

对于每一组数据，给出一行输出，输出摆放的方案数目C（数据保证C<231）。

### 【输入样例】

```
2 1
#.
.#
4 4
...#
..#.
.#..
#...
-1 -1 
```
### 【输出样例】
```
2
1
```

### 【题解】

类似于八皇后，但是因为棋盘有些格不能放棋子，而且棋子数量不一定，所以属于八皇后进阶版（好在这些棋子不影响斜线）

首先，先制定策略，决定和八皇后相似，一行一行推（反正一行只能放一个）

在判断是否放的时候，不光考虑该格有没有被其他棋子控制，也要考虑棋盘是否允许

因为k<=n，所以如果每行都放，是搜不到底的，这时候就要枚举当前行之后的每一行，判断从现在开始，哪行放，哪行不放，只要k个棋子都放完就跳出，这样就能找出所有可能的方案。

代码：

```c++
#pragma warning(disable:4996)//防止vs爆scanf、printf
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
long long ans;//答案
int n, k;
bool bj[10], a[10][10];//bj记录的第i列是否有棋子
char ch;//辅助输入
long long dfs(int x, int rest) {//返回从第x行开始放，放完rest个棋子的方案数
    if (rest == 0) {//放完了
        return 1;//可行方案+1
    }
    long long tot = 0;//还没放完，继续放（如果已经结束，当前行为n+1，在下一行的for语句就跳出了）
    for (int o = x; o <= n; o++) {//枚举放棋子的第o行（实在没字母了）
        for (int l = 1; l <= n; l++) {//枚举第k行的第l列处放一个棋子
            if (a[o][l]) {//棋盘上是“#”
                if (!(bj[l])) {//且这一列之前没棋子控制，可以放棋子
                    bj[l] = 1;//打标记，以后不能放在这一列
                    tot += dfs(o + 1, rest - 1);//继续搜索下一行
                    bj[l] = 0;//别忘了清除标记
                }
            }
        }
    }//这些大括号真难看
    return tot;//返回方案数
}
int main() {
    while (1) {
        scanf("%d%d",&n,&k);
        if ((n == -1) && (k == -1)) {
            break;//判断结束
        }
        memset(a, 0, sizeof(a));
        memset(bj, 0, sizeof(bj));//清空数组
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                cin>>ch;//读入数据
                if (ch == '#') {
                    a[i][j] = 1;
                }
                else {
                    a[i][j] = 0;//其实前面不用清a数组，这里已经消除了上一轮的影响
                }
            }
        }
        ans = dfs(1, k);//从第一行开始搜
        printf("%lld\n", ans);
    }
    return 0;
}
```



感谢[题解](https://blog.csdn.net/u011815404/article/details/80282634)提供的思路支持！