# ybt1200 分解因数

### 【题目描述】

给出一个正整数a，要求分解成若干个正整数的乘积，即a=a1×a2×a3×...×an，并且1<a1≤a2≤a3≤...≤an，问这样的分解的种数有多少。注意到a=a也是一种分解。

### 【输入】

第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a(1<a<32768)。

### 【输出】

n行，每行输出对应一个输入。输出应是一个正整数，指明满足要求的分解的种数。

### 【输入样例】

```
2
2
20
```
### 【输出样例】

```
1
4
```

### 【题解】

本题只要输出方案数，不用考虑组合方式。为了防止重复，要保证因数的顺序升序排列。

因为每一个数n在分解时，都可以分成一个小于等于根号n的因数a，和一个大于等于根号n的因数b，而且只要确定一个a，另一个b也就确定了:b=n/a。所以只要从小到大枚举a作为本方案内n的最小因数，分解b并保证b的分解方案中b的最小因数大于等于a，这样就保证了n的因数方案中各因数升序排列。

另外，由于sqrt()函数在开方后会出现浮点数，所以就可以转化一下判断a小于等于根号n的语句，易证：
$$
a<=\sqrt n等价于a<=n/a
$$

递归边界就是/已经将/当前的b/分解为/不能/在满足条件(b的最小因子大于等于a)的情况下/继续分解。（强行断句）(累心)

根据以上算法，写出递归函数：

```c++
void f(int a,int b) {//a，b分别是当前的n的较小因数和较大因数(操作将累计将b分成最小因数大于等于a的所有方案数)
    for(int i=a;i<=b;i++) {//分解b，实际上i最后不会达到b，在大约根号b时就会跳出函数
		if((!(b%i))&&(b/i>=i)) {//满足b可以被i整除，并且i小于等于根号b
			ans++;//先将b分解为只有唯一因数(它本身)的情况
			f(i,b/i);//然后再讨论把b分成i和b/i的情况
		}
		if(b/i<i)//i大于根号b,结束递归
         	return;
    }
    return;//不会被执行到，详见第二行注释，但是会使强迫症舒服
}
```

接下来很容易就打出完整代码：

```c++
#include<iostream>
using namespace std;
int ans,n,t;
void f(int a,int b);
int main() {
    cin>>t;
    for(int k=1;k<=t;k++) {
        ans=1;//这要算上n本身作为唯一因数的情况
        cin>>n;
        f(2,n);//前面已经讨论了1*n的情况，这里要跳过，从2开始递归
        cout<<ans<<endl;
    }
    return 0;
}
```

# 新年快乐鸭！

## 感谢[题解](https://blog.csdn.net/Wchenchen0/article/details/81077489)提供的算法帮助！


