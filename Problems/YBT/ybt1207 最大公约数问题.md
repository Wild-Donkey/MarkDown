# ybt1207 最大公约数问题

##递归典例

####（选它只是因为太典型，不是因为懒得做难题故意放水）

### 【题目描述】

给定两个正整数，求它们的最大公约数。

### 【输入】

输入一行，包含两个正整数(<1,000,000,000)。

### 【输出】

输出一个正整数，即这两个正整数的最大公约数。

### 【输入样例】

```
6 9
```
### 【输出样例】
```
3
```
### 【题解】

求最大公约数明明可以两个数同时试除所有小于等于它们的算术平方根的质数，然后把整除的数累乘，得到结果，但是这种算法不光写起来很麻烦，而且的复杂度是：
$$
O(\sqrt{n})
$$
很显然，辗转相除是一个更好的方案，辗转相除法，这种算法是用大的数除以小的数（舍掉余数），然后所得的商作为较小的数，之前较小的数作为较大的数，进行同样的运算，直到较小的数为0，这时较大的数便就是一开始两数的最大公约数。

这种算法的复杂度为：
$$
O(log(n))
$$
非常的优秀，堪称递归界的一股清流。

接下来看看代码（故意加很多回车显得代码很长）

```c++
#include<iostream>
using namespace std;
int a;
int b;
int gcd(int a,int b)//算法主体
{
	if(b==0)
	{
		return a;
	}
	return f(b,a%b);
} 
int main()
{
	cin>>a>>b;
	if(b>a)//保证a大
	{
		int t;
         t=a;
		a=b;
		b=t;
	}
	cout<<gcd(a,b)<<endl;
	return 0;
}
```