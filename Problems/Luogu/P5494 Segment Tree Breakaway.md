## 题意

**[Luogu P5494](https://www.luogu.com.cn/problem/P5494)**

维护几个可重集, 支持从一个可重集分裂出 $[l,r]$ 的元素, 合并两个可重集, 在一个可重集中加入若干元素, 查询某可重集对应值域元素数和第 $k$ 小数.

值域 $n$ 满足 $1 \leq n \leq 2 * 10^5$

操作数 $m$ 满足 $1 \leq m \leq 2 * 10^5$

## 权值线段树

小值域暗示建立以值域为区间的权值线段树, 而每个可重集对应的权值线段树又能很好地满足两种查询的需要.

尝试根据题意, 建立 $m$ 个权值线段树, 根据操作要求进行线段树修改. 但是如果仅仅是这样, 一次分裂和合并操作就要浪费 $O(nlogn)$ 的复杂度 (以分裂为例, 先枚举值域 $O(n)$, 然后在原树上进行单点修改 $O(logn)$, 并且记录原树上的值, 在目标树上进行单点修改 $O(logn)$. 而合并也就相当于以一棵树为原树, 另一棵为目标树, 将原树的整个值域分裂到目标树上, 所以两种操作在这种做法本质相同).

这种做法的空间复杂度来到了 $O(mn)$

## 动态开点

一般这种暴力需要多个线段树的题, 正解一般都会用到动态开点. 不过和可持久化不同的是, 线段树分裂的内核不是共享, 而是真正意义上的继承.

将空间复杂度优化到 $((n+ m)logn)$

## 子树继承

但是动态开点不能优化时间复杂度, 于是就引出了这种操作.

首先这个名字是我起的, 因为~~找不到名词做小标题~~这比较形象地描述了线段树合并和分裂的过程.

有些认真阅读的人可能要说 "欸, 你不是之前说可持久化是继承吗, 怎么现在又说线段树分裂才是继承?"

这只是一个相对的说法, 说可持久化继承是因为这种思想和面向对象中的类的继承有异曲同工之处, 多棵树共享一棵子树, 无需多倍存储. 而线段树分裂所说的继承相对来说更像是现实生活中的继承的概念. 继承意味着上一代人的财富向下一代转移, 继承了以后, 上一代就没有了, 不然银行总不能给你复制一份吧.

这里花了许多笔墨讨论线段树分裂和可持久化的区别, 其实是为了找出其中的相似之处, 即两棵树同步遍历, 直接将子树给别的点.

## 同步遍历

同步遍历也是计算机学家沃茨基朔德定义的一个名词, 因为~~没有小标题~~我没有找到合适的名词方便的表示. 遍历线段树时, 参数中两个代表线段树中节点的指针, 分别位于两棵定义域相同的线段树的同一位置, 表示同一区间, 为了方便称呼, 给这种节点取名叫 `同位节点` (这篇文章里第三次了).

在递归过程中, 一个节点往左子树走, 两个节点就都往左子树走.

## 时间复杂度

$_{看不懂没关系, 知道复杂度没锅能过就行}$

普通线段树上的操作在本题中复杂度不变, 该 $O(logn)$ 还是 $O(logn)$.

对于分裂, 相当于特殊的查询, 只是将查询结果挖出, 存入了新的线段树, 所以还是 $O(logn)$.

合并就有些麻烦, 如果是不重复的区间, 那 $O(logn)$ 也是可以保证的, 但是如果区间有重复, 那么就要在两棵树上遍历和这段重复区间有关的所有节点, 最坏情况是 $O(n)$. 但是要想得到两棵重复区间节点数达到 $O(n)$ 级别的线段树, 就要$O(n)$ 次单点修改 (仔细想一想, 如果在空树上进行两次大区间修改是不行的, 因为单个线段树是动态开点的). 将一次合并的 $O(n)$ 均摊到 $O(n)$ 次 $O(logn)$ 的操作上, 单次操作还是 $O(logn)$.

## 实现

### 存储

```cpp
struct Node {
  Node *L, *R;
  unsigned long long Val;
} N[4000005], *Cntn(N), *Vrsn[200005];//和可持久化类似, Vrsn[]存每个线段树的根
```

### 建树

和一般线段树类似的操作, 是权值线段树.

```cpp
void Bld(Node *x, unsigned int l, const unsigned int &r) {
  if (l == r) {  //边界
    x->Val = a[l];
    return;
  }
  unsigned int m((l + r) >> 1);
  Bld(x->L = ++Cntn, l, m);
  Bld(x->R = ++Cntn, m + 1, r);  //递归
  x->Val = 0;                    //统计区间元素总个数
  if (x->L) {
    x->Val += x->L->Val;
  }
  if (x->R) {
    x->Val += x->R->Val;
  }
  return;
}
```

### 分裂

同步遍历, 随时开点.



### 单点修改

和一般线段树类似, 就是单点修改.

```cpp
void Chnge(Node *x, unsigned int l, const unsigned int &r) {
  x->Val += C;  //自己的子集增加 C 个元素, 先给自己加上 C
  if (l == r) {
    return;
  }
  unsigned int m((l + r) >> 1);
  if (D <= m && D >= l) {  //在左
    if (!(x->L)) {
      x->L = ++Cntn;  //开点
    }
    return Chnge(x->L, l, m);
  }
  if (D <= r && D >= m + 1) {  //在右
    if (!(x->R)) {
      x->R = ++Cntn;  //开点
    }
    return Chnge(x->R, m + 1, r);
  }
  return;
}
```

### 查询

和普通线段树无异.

```cpp
void Qry(Node *x, unsigned int l, const unsigned int &r) {
  if (l == r) {  //边界
    Lst = x->Val;
    return;
  }
  unsigned int m = (l + r) >> 1;
  if (C <= m) {           //左边
    Qry(x->L, l, m);      //递归左儿子
  } else {                //右边
    Qry(x->R, m + 1, r);  //递归右儿子
  }
  return;
}
```

### `main()`

头文件, 快读 `RD()` 等略.

```cpp
int main() {
  n = RD();
  m = RD();
  for (register int i(1); i <= n; ++i) {
    a[i] = RD();
  }
  Bld(N, 1, n);  //建树
  Vrsn[0] = N;   //原始版本
  for (register int i(1); i <= m; ++i) {
    A = RD();
    B = RD();
    C = RD();
    if (B == 1) {  //修改
      D = RD();
      Vrsn[i] = ++Cntn;  //新建一个版本
      Chg(Vrsn[i], Vrsn[A], 1, n);
    } else {
      Vrsn[i] = Vrsn[A];  //无需修改, 当前版本即所查询的版本
      Qry(Vrsn[i], 1, n);
      printf("%d\n", Lst);  //查询结果已经记录在Lst中
    }
  }
  return 0;
}
```
