# p1220关路灯(小优化)

## ----对区间DP标程的空间优化

## 题目描述

某一村庄在一条路线上安装了 *n* 盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。

为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。

现在已知老张走的速度为1*m*/*s*，每个路灯的位置（是一个整数，即距路线起点的距离，单位：*m*）、功率（*W*），老张关灯所用的时间很短而可以忽略不计。

请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。

## 输入格式

第一行是两个数字 *n*（表示路灯的总数）和 *c*（老张所处位置的路灯号）；

接下来 *n* 行，每行两个数据，表示第 1 盏到第 *n* 盏路灯的位置和功率。数据保证路灯位置单调递增。

## 输出格式

一个数据，即最少的功耗（单位：J）。

## 输入输出样例

**输入**

```
5 3
2 10
3 20
5 20
6 30
8 10
```

**输出**

```
270  
```

## 题解

本题使用区间DP, 用f数组存储每个区间的功耗最小值.

由于关灯不需要时间, 所以被经过的地方的灯肯定已经关了, 所以关掉一个区间内所有灯后, 人的位置不在左端点, 就在右端点.

边界条件为: 只有起点一盏灯时, 关掉不需要时间, 自然无功耗.

区间功耗最小值可以通过比它短一盏灯的区间的功耗加上关闭多出来的那盏灯的功耗推得.

每个区间的功耗最小值可以分成两种情况: 从左边界结束和从右边界结束.

如果是从[i,j]左边结束, 那么就不能使用[i,j-1]区间的数据, 因为灯i是最后一个关闭的, 所以不能提前关闭.

以此类推:

[i,j]从左边结束的最小值可以通过[i+1,j]的数据推得;

[i,j]从右边结束的最小值可以通过[i,j-1]的数据推得;

因为区间起点一定比终点小, 所以f数组会有一半以上无法利用.

为了节省空间, 所以将[i,j]区间从左边结束的最小功耗存在f(i,j)中; 从右边结束的最小功耗存在f(j,i)中.

这便是在常规操作的基础上做出的小优化.

写出超级复杂的状态转移方程:
$$
f(i,j)=
\left\{
\begin{aligned}
min(f[i + 1][j] + (L[i + 1] - L[i]) * (sum[i] + sum[n] - sum[j]),\ 
f[j][i + 1] + (L[j] - L[i]) * (sum[i] + sum[n] - sum[j]))\ \ \ \ (i<j)
\\
min(f[j][i - 1] + (L[i] - L[j]) * (sum[j - 1] + sum[n] - sum[i - 1]),\ 
f[i - 1][j] + (L[i] - L[i - 1]) * (sum[j - 1] + sum[n] - sum[i - 1]))\ \ \ \ (i>j)
\end{aligned}
\right.
$$


AC代码:

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int n, L[1005]/*坐标*/, P[1005]/*功率*/, at, sum[1005]/*功率前缀和*/, f[1005][1005];
bool flg[1005];
int main() {
	cin >> n >> at;
	memset(f, 0x3f, sizeof(f));//赋inf方便更新
	for (int i = 1; i <= n; i++) {
		cin >> L[i] >> P[i];
		sum[i] = sum[i - 1] + P[i];//处理前缀和
	}
	f[at][at] = 0;//所在的灯不需要时间
	for (int l = 2; l <= n; l++) {//枚举区间长度
		for (int i = 1; i + l - 1 <= n; i++) {//枚举区间起点
			int j = i + l - 1;//推算区间终点
			f[i][j] = min(f[i + 1][j] + (L[i + 1] - L[i]/*从上个区间起点到本起点的距离(时间)*/) * (sum[i] + sum[n] - sum[j]/*还亮着的灯的总功率*/)/*上一个区间从左边结束的方案*/, f[j][i + 1] + (L[j] - L[i]/*从终点到起点的距离(时间)*/) * (sum[i] + sum[n] - sum[j]/*还亮着的灯的总功率*/)/*上一个区间从右边结束的方案*/);//本区间[i,j]从左边结束, 由上一个区间[i+1,j]推得
			f[j][i] = min(f[i][j - 1] + L[j] - L[i]) * (sum[i - 1] + sum[n] - sum[j - 1]), f[j - 1][i] + (L[j] - L[j - 1]) * (sum[i - 1] + sum[n] - sum[j - 1]));//基本同理, 本区间[i,j]从右边结束, 由上一个区间[i,j-1]推得
		}
	}
	cout << min(f[1][n], f[n][1]) << endl;
	return 0;
}
```

