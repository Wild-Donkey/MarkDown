# 省选日记 Day $-9$ - Day $-5$

## Day $-9$ Mar 25, 2022, Friday

### [ARC059F](https://atcoder.jp/contests/arc059/tasks/arc059_d)
看到这里的题解都是二维 DP, 我是从卡特兰数的方面考虑的此题. 

如果这个题的模数换成 $998244343$ 或是别的 NTT 模数, 那么复杂度就可以通过分治 FFT 做到 $O(n\log^2 n)$. 可惜换不得. 但是貌似存在某神奇的多项式科技任意模数 NTT, 那么理论上还是可以 $O(n\log^2 n)$ 的.

但是本题解只对 $O(n^2)$ 的做法进行实现.

前置知识: 可以在[这里](https://www.luogu.com.cn/blog/Wild-Donkey/zroi-day11-day20-bi-ji) Day19 的 C 题笔记中找到卡特兰数的推导和变形, 也可以查看 [Wiki](https://zh.wikipedia.org/zh-hans/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0).

给一个 0/1 串 $S$, 每次可以选择在末尾插入一个 `0` 或 `1`, 或删除最后一个字符. 求进行 $n$ 次操作之后得到 $S$ 的方案数.

注意到一个比较头疼的事情是在没有字符的时候按退格, 这样的退格不会删除任何东西, 且一旦出现无效退格, 一定不存在任何字符. (废话) 所以可以认为是一个新的子问题.

设操作 $i$ 次, 操作 $i$ 是无效退格的方案数为 $f_i$. 

为了求这个 $f$, 我们需要计算从 $0$ 个字符开始, 不断进行操作, 但是禁止无效退格. 进行 $2i$ 次操作的方案数为 $g_i$. 这样会打出 $i$ 个字符, 并且这 $i$ 个字符会被 $i$ 个有效退格删掉. 这个问题等价于将 `0` 和 `1` 压入栈并且弹出. 可以看出 $g_i$ 等于卡特兰数第 $i$ 项乘 $2^i$. $2^i$ 枚举了每个插入的字符是 `0` 还是 `1`, 卡特兰数第 $1$ 项枚举了每个退格的时刻.

求出了 $g$, 我们枚举倒数第二次无效空格的时刻 $i - 1 - 2j$, 则 $f_i$ 可以表示为:

$$
f_i = \sum_{j = 0}^{\lfloor \frac {i - 1}2 \rfloor} f_{i - 1 - 2j}g_j
$$

这是卷积的形式, 我们可以使得 $g'_{2i + 1} = g_i$, 然后让 $g'$ 其余项为 $0$, 那么式子就变成:

$$
f_i = \sum_{j = 1}^{i} f_{i - j}g'_{j}
$$

可以用分治 FFT 优化到 $O(n\log^2 n)$, 所以这个题理论上是可以 $O(n \log^2 n)$ 的. 有需要的人可以拿去出个加强版, 把模数换成 $998244353$ 然后把 $n$ 开到 $10^5$ 什么的.

我们枚举最后一个无效退格的时刻 $x$. 那么相当于是在禁止无效退格的情况下用 $n - x$ 次操作得到目标串. 所以我们枚举 $x$, 对不同的 $x$ 算 $n - x$ 答案即可.

接下来考虑禁止无效退格, 用 $x$ 次操作凑出目标串的方案数.

设 $S$ 的长度为 $m$, 那么我们知道会有 $\dfrac{x + m}2$ 次插入操作, 剩下的是删除操作. 所以需要 $x$, $m$ 奇偶性相同. 否则方案数为 $0$.

我们先不管 $x$ 次操作后的串是什么, 求出只存在 `0` 的情况下, $x$ 次操作后留下 $m$ 个 `0` 的方案数. 显然是卡特兰数的变形, 也就是 $\dbinom x{\frac {x + m}2} - \dbinom x{\frac {x + m}2 + 1}$.

最后我们考虑既有 `0` 也有 `1` 的情况. 对于被删除了的 $\dfrac {x - m}{2}$ 次插入, 我们允许它们是任何数字, 剩下的 $m$ 个未被删除的插入, 它们必须是目标位置的数字. 因此只要在原来只有 `0` 的方案数的基础上乘以 $2^{\frac{x - m}2}$ 即可.

这里没有对分治 FFT 进行任意模数 NTT 的实现. 只写了暴力卷积:

```cpp
const unsigned long long Mod(1000000007);
unsigned long long Fac[5005], Inv[5005], Two[5005], g[5005], f[5005], Ans(0);
unsigned m, n;
inline unsigned long long Inver(unsigned long long x) {
  unsigned long long Rt(1);
  unsigned y(1000000005);
  while (y) { if(y & 1) Rt = Rt * x % Mod; x = x * x % Mod, y >>= 1;}
  return Rt;
}
inline unsigned long long Solve(unsigned x) {
  unsigned Typ((x + m) >> 1);
  unsigned long long A(Two[Typ - m]), B(Inv[Typ] * Inv[x - Typ] % Mod);
  A = A * Fac[x] % Mod;
  B = B * A % Mod, Typ = x - Typ;
  if(Typ) --Typ, A = A * Inv[Typ] % Mod, A = A * Inv[x - Typ] % Mod;
  else A = 0;
  return Mod + B - A;
}
signed main() {
  n = RD(), f[0] = g[0] = Fac[0] = Two[0] = 1;
  while (getchar() >= '0') ++m;
  for (unsigned i(1); i <= n; ++i) Fac[i] = Fac[i - 1] * i % Mod;
  Inv[n] = Inver(Fac[n]);
  for (unsigned i(n); i; --i) Inv[i - 1] = Inv[i] * i % Mod;
  for (unsigned i(1); i <= n; ++i) Two[i] = (Two[i - 1] << 1), Two[i] -= (Two[i] >= Mod) ? Mod : 0;
  for (unsigned i(n >> 1); i; --i)
    g[i] = (((Fac[i << 1] * Inv[i + 1] % Mod) * Inv[i] % Mod) * Two[i]) % Mod;
  for (unsigned i(1); i <= n; ++i) for (unsigned j((i - 1) >> 1); ~j; --j)
    f[i] = (f[i] + f[i - 1 - (j << 1)] * g[j]) % Mod;
  for (unsigned i(n - m); ~i; --i) if(!(((n - i) ^ m) & 1))
    Ans = (Ans + f[i] * Solve(n - i)) % Mod;
  printf("%llu\n", Ans);
  return Wild_Donkey;
}
```

## Day $-8$ Mar 26, 2022, Saturday

### NOIO-S T1

这里有一个结论. 对于 $i < x$, 如果从 $i$ 开始入栈, $x$ 是成功的, 那么从 $i + 1$ 开始入栈, $x$ 也一定是成功的. 我们可以从 $1$ 开始把所有东西入栈. 取一个元素 $x$ 入栈后的前一个元素 $y$, 我们知道从 $y + 1$ 开始入栈, $x$ 就是成功的了. 把每个元素成功需要的最小起点记录为 $Left$ 数组.

起床 $8:30$ 就离谱, 在床上就火速开电脑. 立马看题, 一边做饭一遍想, 但是想错了. 当时一直认为上面这个结论是错的, 以至于把这个题想得很难. 到了机房九点接近半了, 直接比别人少了一个小时.

接下来我们要解决的就是在区间 $[L, R]$ 内, 对 $Left_i \leq L$ 的 $i$ 计数. 可以使用可持久化权值线段树直接查询, 也可以对所有询问拆成 $i \leq R$, $i < L$ 两个询问, 将每个询问排序后, 用树状数组一遍插入, 一边询问前缀和.

我写挂了, 是因为排序时重载询问的小于号, 把比较规则设为了小于等于号. 我把 T1 大样例过了, 并且因为大样例本地 $0.8s$ 我很慌张, 发现输出占了 $0.5s+$, 怒写快写, 时间卡到 $0.3s$ 心满意足. 没想到这种明显的 RE 错误都没有看出来.

### NOIO-S T2

这个题当时没有想出来, 因为我给 T1 卡完常就快 $11:00$ 了. 于是当时开始努力拿暴力.

我一开始认为, 这个暴力拿 `bitset` 随便冲不就是了? 结果事后在民间数据提交发现连 $5000$ 的点都过不了.

正解其实很无脑, 我们考虑如果依次对每个人会做的题染色, 每次遍历到一个人, 就判断它会做的题是否是一个颜色, 如果是, 说明他是别人的子集. 如果不是, 有两种情况, 他包含别人或者是找到了答案. 为了避免他包含别人的情况, 我们只要把人按照会题数量排序即可. 这样我们只要取我们会的题中, 不是最大的那个颜色作为答案的一个人, 当前遍历的人作为另一个人即可.

### NOIO-S T3

其实这个暴力是好写

### [常系数齐次线性递推](https://www.luogu.com.cn/problem/P4723)

给 $f$, 和 $a$ 的前 $k$ 项, 求 $a_n$. $a$ 满足

$$
a_n = \sum_{i = 1}^k f_ia_{n - i}
$$

一般遇到这种问题我们都会选择用矩阵快速幂进行转移, 但是这里 $k$ 的大小高达 $32000$, 所以无从下手.

先考虑 $n$ 较小的情况, 我们发现如果把 $a_i$ 到 $a_{i + j}$ 的总贡献 $F_j$ 看成一个多项式 $\displaystyle\sum_{j = 0}^{\infin} x^jF_j$. 发现满足这样的式子:

$$
F_i = \sum_{j = 1}^{i} F_{i - j}f_j
$$

可以使用分治 FFT 求出这个多项式. 复杂度 $O(n\log^2 n)$. 然后就可以 $O(n)$ 算出答案.

但是 $n$ 的范围是 $10^9$. 所以这个做法也寄了.


```cpp

```