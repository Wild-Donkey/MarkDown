# 省选日记-终章 (SDOI2022 游记)

SDOI 重出江湖后被推迟到了 $5$ 月 $15$ 日, 一天考完 Day1 和 Day2. 推迟了 $41$ 天, 是时候有个交代了.

## Day $41$ May 14, 2022, Saturday

明天省选, 今天继续打板子.

### [P5055 可持久化文艺平衡树](https://www.luogu.com.cn/problem/P5055)

发现可持久化文艺平衡树没写, 意识到自己可持久化平衡树都是 WBLT, 自带两倍点数, 加上自己的代码使用了指针, 自带两倍空间, 所以空间是一般平衡树的四倍, 十分有可能被卡空. 不过可持久化之后点数的差距就没有那么明显了, 所以仍然是 WBLT.

这里看到一个 WBLT 的合并方式明显要比我之前的东周平衡树先进. 如果合并到两棵树的大小相差不超过阈值, 那么直接合并为一个父亲的两个儿子, 否则分类讨论, 如果将较小的树和较大的树的对应儿子合并后, 新树的大小相差不超过阈值, 那么就合并之, 否则先旋转再合并.

```cpp
long long OV, Ans(0);
unsigned m, n, A, B, C, D;
struct Node {
  Node* LS, *RS;
  long long Val;
  unsigned Size;
  char Flip;
  inline void Prt();
  inline void Udt() {
    Size = (LS ? LS->Size : 0) + (RS ? RS->Size : 0);
    Val = (LS ? LS->Val : 0) + (RS ? RS->Val : 0);
  }
  inline void PsDw();
  inline Node *Rotate();
  inline Node *Insert(unsigned x);
  inline Node *Delete(unsigned x);
  inline Node *Merge(Node* x);
  inline void Split(Node*& x, Node*& y, unsigned z); 
}N[40000005], *Ver[200005], *CntN(N);
inline void Node::Prt(){
  printf("Node%u: Size %u Val %lld Flg %u LS %u(%u) RS %u(%u)\n", this - N, Size, Val, Flip, LS - N, LS ? LS->Size : 0, RS - N, RS ? RS->Size : 0);
}
inline void Node::PsDw() {
  if(Flip) swap(LS, RS);
  if(LS) *(++CntN) = *LS, LS = CntN, LS->Flip ^= Flip;
  if(RS) *(++CntN) = *RS, RS = CntN, RS->Flip ^= Flip;
  Flip = 0;
}
inline Node *Node::Rotate() {
  if(!LS) return RS;
  if(!RS) return LS;
  if(Size <= 5) return this;
  if((LS->Size << 1) < RS->Size) {
    Node* Cur(RS);
    Cur->PsDw(), RS = Cur->RS, Cur->RS = Cur->LS;
    Cur->LS = LS, LS = Cur, Cur->Udt();
    return this;
  }
  if((RS->Size << 1) < LS->Size) {
    Node* Cur(LS);
    Cur->PsDw(), LS = Cur->LS, Cur->LS = Cur->RS;
    Cur->RS = RS, RS = Cur, Cur->Udt(); 
    return this;
  }
  return this;
}
inline Node *Node::Insert(unsigned x) {
  if(Size == 1) {
    *(LS = ++CntN) = {NULL, NULL, x ? Val : OV, 1, 0};
    *(RS = ++CntN) = {NULL, NULL, x ? OV : Val, 1, 0};
    Flip = 0, Val = Val + OV, Size = 2; 
    return this;
  }
  PsDw();
  if(x <= LS->Size) LS = LS->Insert(x);
  else RS = RS->Insert(x - LS->Size);
  Udt();
  return Rotate();
}
inline Node *Node::Delete(unsigned x) {
  if(Size == 1) return NULL;
  PsDw();
  if(x <= LS->Size) LS = LS->Delete(x);
  else RS = RS->Delete(x - LS->Size);
  Udt();
  return Rotate();
}
inline Node *Node::Merge(Node* x) {
  if(Size + x->Size <= 5) {
    *(++CntN) = {this, x, Val + x->Val, Size + x->Size, 0};
    return CntN;
  }
  if(Size > (x->Size << 1)) {PsDw(), RS = RS->Merge(x), Udt(); return this;}
  if(x->Size > (Size << 1)) {x->PsDw(), x->LS = Merge(x->LS), x->Udt(); return x;}
  *(++CntN) = {this, x, Val + x->Val, Size + x->Size, 0};
  return CntN;
}
inline void Node::Split(Node*& x, Node*& y, unsigned z) {
  PsDw();
  if(LS->Size == z) {x = LS, y = RS;return;}
  Node *Cur;
  if(LS->Size > z) LS->Split(x, Cur, z), y = Cur->Merge(RS);
  else RS->Split(Cur, y, z - LS->Size), x = LS->Merge(Cur);
}
signed main() {
  n = RD();
  for (unsigned i(1); i <= n; ++i) {
    A = RD(), B = RD(), C = RD() ^ Ans;
    switch(B) {
      case (1) :{
        OV = RD() ^ Ans;
        if(!Ver[A]) *(Ver[i] = ++CntN) = {NULL, NULL, OV, 1, 0};
        else *(Ver[i] = ++CntN) = *Ver[A], Ver[i]->Insert(C);
        break;
      }
      case (2) :{
        *(Ver[i] = ++CntN) = *Ver[A], Ver[i]->Delete(C);
        break;
      }
      default :{
        D = RD() ^ Ans;
        Node* Part1, *Part2, *Part3;
        *(Ver[i] = ++CntN) = *Ver[A];
        if(C > 1) Ver[i]->Split(Part1, Part2, C - 1);
        else Part2 = Ver[i], Part1 = NULL;
        if(D ^ Ver[i]->Size) Part2->Split(Part2, Part3, D - C + 1);
        else Part3 = NULL;
//        printf("Done\n"); 
        if(B & 1) Part2->Flip ^= 1;
        else printf("%lld\n", Ans = Part2->Val);
        if(Part3) Part2 = Part2->Merge(Part3);
        if(Part1) Ver[i] = Part1->Merge(Part2);
        else Ver[i] = Part2;
        break;
      }
    }
  }
  return Wild_Donkey;
}
```

### [CTSC2012 熟悉的文章](https://www.luogu.com.cn/problem/P4022)

当时补正睿的时候做到过这道题, 但是因为太难跳过了, 今天当成 SAM 的板子打一下.

一开始想出 $O(n\log^2 n)$ 的时候还疑惑为什么这个题可以用 ACAM 做. 后来发现 ACAM 只能识别前缀, 不能识别子串. 所以还是得建 GSAM. 接下来是真正的 $O(n\log^2 n)$ 做法.

可以对模式串建立 GSAM, 然后对询问串的每一个前缀得到一个和所有模式串的 LCS (最长公共后缀). 记 $a_i$ 为第 $i$ 个前缀和所有模式串的 LCS. 接下来二分 $L$, 用 DP 验证可行性.

我们把所有串反过来, 那么统计的 $a$ 就成了 LCP 序列, 设计状态 $f_i$ 表示前缀 $i$ 的分割最少有多少没有被划分为熟悉子串的字符. 那么可以写出方程:

$$
\begin{aligned}
f_{i + j} &= \min (f_{i + j}, f_i) &\left(j \in [L, a_{i + 1}]\right)\\
f_{i + 1} &= \min (f_{i + 1}, f_i + 1)
\end{aligned}
$$

初始是 $f_i = i$, 可以用线段树优化转移, 单次判断 $O(n\log n)$.

算上二分 $L$, 总复杂度 $O(n\log^2n)$.

```cpp
unsigned a[1100005];
unsigned m, n, Len;
unsigned A, B, C, D, t;
unsigned Cnt(0), Ans(0), Match;
char SPool[1100005], *S(SPool);
struct Seg {
  Seg* LS, *RS;
  unsigned Tag;
  inline void PsDw() {
    LS->Tag = min(LS->Tag, Tag);
    RS->Tag = min(RS->Tag, Tag);
  }
  inline void Build(unsigned L, unsigned R);
  inline void Edit (unsigned L, unsigned R) {
    if(A <= L && R <= B) {Tag = min(Tag, C); return;}
    PsDw();
    unsigned Mid((L + R) >> 1);
    if(A <= Mid) LS->Edit(L, Mid);
    if(B > Mid) RS->Edit(Mid + 1, R);
  }
  inline void Find (unsigned L, unsigned R) {
    if(L == R) {B = Tag; return;}
    PsDw();
    unsigned Mid((L + R) >> 1);
    if(A <= Mid) LS->Find(L, Mid);
    else RS->Find(Mid + 1, R);
  }
}Se[2200005], *CntS(Se);
inline void Seg::Build(unsigned L, unsigned R) {
  Tag = 0x3f3f3f3f;
  if(L == R) { LS = RS = NULL; return; }
  unsigned Mid((L + R) >> 1);
  (LS = ++CntS)->Build(L, Mid);
  (RS = ++CntS)->Build(Mid + 1, R);
}
inline char Judge (unsigned x) {
  if(!x) return 1;
  (CntS = Se)->Build(1, Len);
  unsigned Cur(0);
  for (unsigned i(0); i < Len; ++i) {
    if(a[i + 1] >= x)
      A = i + x, B = i + a[i + 1], C = Cur, Se->Edit(1, Len);
    A = i + 1, Se->Find(1, Len), Cur = min(Cur + 1, B);
  }
  return Cur <= (Len * 0.1);
}
inline void Solve () {
  unsigned L(0), R(Len), Mid;
  while (L ^ R) {
    Mid = ((L + R + 1) >> 1);
    if(Judge(Mid)) L = Mid;
    else R = Mid - 1; 
  }
  printf("%u\n", L);
}
struct Node{
  Node *E[2], *Fail;
  unsigned Len;
  inline void Prt();
  inline Node*Find(char c);
  inline Node*Add(char c);
}N[2200005], *CntN(N);
inline void Node::Prt() {
  printf("Node%u: Sons %u %u Fail %u Len %u\n", this - N, E[0] - N, E[1] - N, Fail - N, Len);
}
inline Node* Node::Find(char c) {
  if(E[c]) {++Match; return E[c];}
  Node* Back(Fail);
  while (Back && (!Back->E[c])) Back = Back->Fail;
  Match = Back ? (Back->Len + 1) : 0;
  return Back ? Back->E[c] : N;
}
inline Node* Node::Add(char c) {
  if(E[c]) {
    if(E[c]->Len == Len + 1) return E[c];
    Node* Copy(++CntN), *Back(this), *Ori(E[c]);
    *Copy = *E[c], Copy->Len = Len + 1, Ori->Fail = Copy;
    while (Back && (Back->E[c] == Ori)) Back->E[c] = Copy, Back = Back->Fail;
    return Copy;
  }
  Node*Cur(++CntN), *Back(this);
  Cur->Len = Len + 1;
  while (Back && (!Back->E[c])) Back->E[c] = Cur, Back = Back->Fail;
  if(!Back) {Cur->Fail = N; return Cur;}
  if(Back->E[c]->Len == Back->Len + 1) {Cur->Fail = Back->E[c]; return Cur;}
  Node*Copy(++CntN), *Ori(Back->E[c]);
  *Copy = *Ori, Copy->Len = Back->Len + 1;
  Cur->Fail = Ori->Fail = Copy;
  while (Back && (Back->E[c] == Ori)) Back->E[c] = Copy, Back = Back->Fail;
  return Cur;
}
signed main() {
  n = RD(), m = RD();
  for (unsigned i(1); i <= m; ++i) {
    scanf("%s", S), Len = strlen(S);
    Node* Cur(N);
    for (unsigned j(0); j < Len; ++j) Cur = Cur->Add(S[j] - '0');
    S = S + Len;
  }
  for (unsigned i(1); i <= n; ++i) {
    Node* Cur(N);
    scanf("%s", S), Len = strlen(S), Match = 0;
    for (unsigned j(0); j < Len; ++j)
      Cur = Cur->Find(S[j] - '0'), a[Len - j] = Match;
    S = S + Len;
    Solve();
  }
  return Wild_Donkey;
}
```

写完以后小调之后过了样例, 提交有了 $80'$, 喜出望外这次的 GSAM 一次写对了, 但是复杂度上的缺陷确实过不了 $1.1e6$, 开了 `-O2` 拿到了 $90'$.

正难则反, 发现不用把 $a$ 反过来表示 LCP, 设 $a_i$ 仍然表示询问串第 $i$ 个前缀和模式串的 LCS, 设计状态 $f_i$ 表示第 $i$ 个前缀缀最少的没有被标记为熟悉的子串的长度总和, 则有这样的方程:

$$
f_i = \min(f_{i - 1} + 1, \min_{j = L}^{a_i} f_{i - j})
$$

发现这个方程可以用单调队列优化. (虽然这个时候提到单调队列有点搞心态)

对于 $f_a \leq f_b$, $i - L \geq a > b$, $f_b$ 在转移中是无用的, 因此我们维护一个单调队列, 每次转移进行一次二分查找, 并且插入一个元素. 这样仍然是 $O(n\log^2 n)$, 但是常数会减少. 所以最慢一个点 $977ms$ 险过.

所以啊, 年轻人会二分查找是真的好.

> Stop learning useless algorithms, go and solve some problems, learn how to use binary search.   ----Um_nik

```cpp
unsigned a[1100005], f[1100005], Stack[1100005], *STop(Stack);
char SPool[1100005], *S(SPool);
inline char Judge (unsigned x) {
  if(!x) return 1;
  unsigned Cur(0);
  memset(f + 1, 0x3f, Len << 2);
  f[0] = 0;
  for (unsigned i(1); i <= Len; ++i) {
    if(i >= x) {
      while ((STop > Stack) && (f[i - x] <= f[*STop])) --STop;
      *(++STop) = i - x;
    }
    f[i] = f[i - 1] + 1;
    if(a[i] >= x)
      f[i] = min(f[i], f[*lower_bound(Stack + 1, STop + 1, i - a[i])]);
  }
  return f[Len] <= (Len * 0.1);
}
signed main() {
  /*这部分和上一份代码都一样*/
  for (unsigned i(1); i <= n; ++i) {
    Node* Cur(N);
    scanf("%s", S), Len = strlen(S), Match = 0;
    for (unsigned j(0); j < Len; ++j)
      Cur = Cur->Find(S[j] - '0'), a[j + 1] = Match; // 只有这个地方把 a[Len - j] 改成了 a[j + 1]
    S = S + Len;
    Solve();
  }
  return Wild_Donkey;
}
```

不过这道题是有单 log 做法的, 只不过 AC 限制了我的思考, 所以去看题解学习一下.

原理其实很简单, 我们求出来的 $a$ 数组, 由于是一个字符一个字符匹配的, 每次最多增加 $1$, 所以一定有 $a_i + 1 \geq a_{i + 1}$. DP 中, 可以转移 $f_i$ 的状态最小是 $i - a_i$, 因为 $a_i + 1 \geq a_{i + 1}$, 因此 $i - a_i \leq i + 1 - a_{i + 1}$, 因此左边界单调增加, 所以我们可以直接将队尾弹出, 让单调栈真正变成单调队列, 这样就不用二分查找了, 总复杂度 $O(n\log n)$.

代码其余部分都相同.

```cpp
unsigned a[1100005], f[1100005], Que[1100005], *Hd, *Tl;
inline char Judge (unsigned x) {
  if(!x) return 1;
  unsigned Cur(0);
  memset(f + 1, 0x3f, Len << 2);
  f[0] = 0, Hd = Tl = Que; 
  for (unsigned i(1); i <= Len; ++i) {
    if(i >= x) {
      while ((Hd < Tl) && (f[i - x] <= f[*Tl])) --Tl;
      *(++Tl) = i - x;
    }
    f[i] = f[i - 1] + 1;
    while ((Hd < Tl) && ((*(Hd + 1)) < i - a[i])) ++Hd;
    if((Hd < Tl) && (*(Hd + 1) <= i - x)) f[i] = min(f[i], f[*(Hd + 1)]);
  }
  return f[Len] <= (Len * 0.1);
}
```

### [NOI2011 阿狸的打字机](https://www.luogu.com.cn/problem/P2414)

打字机打字的过程其实就是对 Trie 树遍历的过程, 我们可以建一棵 Trie 出来.

如果构造 ACAM, 询问一个字符串在另一个字符串中出现的次数, 就是查询 Fail 树上某个节点的子树中有多少个另一个串也含有的节点.

我们要查询的是 Trie 树上的一条路径上的节点在 Fail 树中的一个子树中出现了多少个, 因此将 Trie 重链剖分, 将问题转化为重链剖分套二维数点.

记一个 DFS 序, 然后在 Fail 树上按 DFS 序建立可持久化权值线段树. 因为是两个共用节点的树形结构, 我们分两个 DFS 序考虑. 设 Trie 树上节点 $i$ 的 DFS 序为 $TrieR_i$, 在 Fail 树上节点 $i$ DFS 序为 $FailR_i$. 这个可持久化权值线段树以 $FailR$ 为版本号, 以 $TrieR$ 为序, 在两个版本上查询就是在一棵 Fail 树的子树上查询, 而区间查询则是查询某个 Tire 树上的链上的节点在这个子树中的数量. 单次查询 $O(n\log^2 n)$.

```cpp
unsigned m, n(0);
unsigned A, B, C, D, t;
unsigned Cnt(0), Ans(0), Tmp(0);
char a[100005];
struct Seg {
  Seg *LS, *RS;
  unsigned Val;
  inline void Insert(Seg* x, unsigned L, unsigned R);
  inline void Find(Seg* x, unsigned L, unsigned R) {
    if(A <= L && R <= B) { Ans += Val - (x ? x->Val : 0);return; }
    unsigned Mid((L + R) >> 1);
    if(A <= Mid && LS) LS->Find(x ? x->LS : NULL, L, Mid);
    if(B > Mid && RS) RS->Find(x ? x->RS : NULL, Mid + 1, R);
  }
}S[2000005], *Ver[100005], *CntS(S);
inline void Seg::Insert(Seg* x, unsigned L, unsigned R) {
  if(x) *this = *x;
  ++Val;
  if(L == R) {return;}
  unsigned Mid((L + R) >> 1);
  if(A <= Mid) (LS = ++CntS)->Insert(x ? x->LS : NULL, L, Mid);
  else (RS = ++CntS)->Insert(x ? x->RS : NULL, Mid + 1, R);
}
struct Node{
  vector<Node*> Son;
  Node *E[26], *Fa, *Fail, *Heavy, *Top;
  unsigned Dep, SizeF, SizeT, FailR, TrieR;
  char My;
  inline void DFST() {
    TrieR = ++Cnt;
    if(Heavy) Heavy->Top = Top, Heavy->DFST();
    for (char i(0); i < 26; ++i) 
      if(E[i] && (E[i] != Heavy)) E[i]->Top = E[i], E[i]->DFST();
  }
  inline void DFSF ();
}N[100005], *List[100005], *Rev[100005], *Last(N), *CntN(N);
inline void Node::DFSF () {
  Rev[FailR = ++Cnt] = this, SizeF = 1;
  for (auto i:Son) i->DFSF(), SizeF += i->SizeF; 
}
inline void BFS() {
  Node* Que[CntN - N + 3], **Hd(Que), **Tl(Que);
  for (char i(0); i < 26; ++i) if(N->E[i]) *(++Tl) = N->E[i];
  while (Hd < Tl) {
    Node *Cur(*(++Hd)), *Back(Cur->Fa->Fail);
    Cur->Dep = Cur->Fa->Dep + 1;
    while (Back && (!(Back->E[Cur->My]))) Back = Back->Fail;
    if(Back && Back->E[Cur->My]) Cur->Fail = Back->E[Cur->My];
    else Cur->Fail = N;
    for (char i(0); i < 26; ++i) if(Cur->E[i]) *(++Tl) = Cur->E[i];
  }
  for (Node** i(Tl); i > Que; --i) {
    (*i)->SizeT = 1;
    unsigned Mx(0);
    for (char j(0); j < 26; ++j) if((*i)->E[j]) {
      (*i)->SizeT += (*i)->E[j]->SizeT;
      if(Mx < (*i)->E[j]->SizeT)
        Mx = ((*i)->Heavy = (*i)->E[j])->SizeT;
    }
  }
}
signed main() {
  scanf("%s", a + 1);
  A = strlen(a + 1), m = RD();
  while (A && (a[A] ^ 'P')) --A;
  for (unsigned i(1); i <= A; ++i) {
    if(a[i] == 'P') {List[++n] = Last; continue;}
    if(a[i] == 'B') {Last = (Last->Fa ? Last->Fa : N); continue;}
    if(!(Last->E[a[i] -= 'a']))
      (Last->E[a[i]] = ++CntN)->Fa = Last, (Last = CntN)->My = a[i];
  }
  BFS(), N->DFST(), Cnt = 0;
  for (Node *i(N + 1); i <= CntN; ++i) i->Fail->Son.push_back(i);
  N->Top = N, N->DFSF();
  for (unsigned i(1); i <= Cnt; ++i)
    A = Rev[i]->TrieR, (Ver[i] = ++CntS)->Insert(Ver[i - 1], 1, Cnt);
  for (unsigned i(1); i <= m; ++i) {
    Node *QrySt(List[RD()]), *ModleSt(List[RD()]);
    Seg *Frm(Ver[QrySt->FailR - 1]), *Too(Ver[QrySt->FailR + QrySt->SizeF - 1]);
    Ans = 0;
    while (ModleSt) {
      A = ModleSt->Top->TrieR, B = ModleSt->TrieR;
      Too->Find(Frm, 1, Cnt);
      ModleSt = ModleSt->Top->Fa;
    }
    printf("%u\n", Ans);
  }
  return Wild_Donkey;
}
```

## Day $42$ May 15, 2022, Sunday

今天是省选 Day1 + Day2, 因为有一点空虚, 所以我迟了好久才过来写游记.

先说结果, 期望 $20 + 35 + 25 + 100 + 10 + 0 = 190$, 实际挂成了 $0 + 35 + 25 + 100 + 2 + 0 = 162$. 山东 RK $24$, 加上 NOIP 成绩 RK $23$. 肯定没有 AB 了, 但是 D 是绝对可以买的.

### D1T1 整数序列

这个题一眼没什么想法, 转化题意为每次询问数轴上有两种点, 选择一个区间使得两种点数量相同且权值总和最大.

之后想到可以类似于括号匹配那样做, 将每个数字的每次出现位置和权值都存到一个 `vector` 里面, 记录一个高度 $h$, 从左往右双指针扫描两个 `vector`, 遇到第一种点就将高度增加 $1$, 遇到第二种点就将高度减少 $1$, 记录每个高度达到过的最小权值前缀和, 每次用当前的高度和前缀和减去这个高度达到过的最小权值前缀和, 尝试更新答案. 复杂度 $O(nq)$.

其实这个数据范围结合时限 (当时还没有改时限, 貌似是 $4s$), 我是十分相信存在根号做法的, 但无论是分块还是莫队我都没有想到什么合理的算法. 将时间改到 $7s$ 之后, 我更加相信这个题绝对是根号, 但是仍无果.

我中途想过每个点开一个动态开点线段树, 可是这个信息无法通过线段树的二分结构来查询, 所以就寄了. 发现可以根号分治, 也就是特殊处理出现次数大于根号个的元素, 通过预处理加速和这些元素有关的询问, 但是发现我不会预处理加速询问, 所以就又往动态开点线段树上去想了.

最后还是交的 $O(nq)$, 但是没有得到预期的 $20'$, 因为有一个地方挂掉了. 接下来是考场代码:

```cpp
#include <algorithm>
#include <bitset>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <unordered_map>
#include <vector>
using namespace std;
inline unsigned RD() {
  unsigned Rtmp(0);
  char Rch(getchar());
  while(Rch < '0' || Rch > '9') Rch = getchar();
  while(Rch >= '0' && Rch <= '9')
    Rtmp = Rtmp * 10 + Rch - '0', Rch = getchar();
  return Rtmp;
}
inline int RDsg() {
  int Rtmp(0), Rsig(1);
  char Rch(getchar());
  while((Rch < '0' || Rch > '9') && (Rch ^ '-')) Rch = getchar();
  if(Rch == '-') Rsig = -1, Rch = getchar();
  while(Rch >= '0' && Rch <= '9')
    Rtmp = Rtmp * 10 + Rch - '0', Rch = getchar();
  return Rtmp * Rsig;
}
long long Sum[600005], Ans(0);
unsigned a[300005];
int b[300005];
vector<pair<unsigned, int> > c[300005];
unsigned n, m;
unsigned A, B, C, D, t;
signed main() {
  freopen("sequence.in", "r", stdin);
////  freopen("ex_sequence3.in", "r", stdin);
  freopen("sequence.out", "w", stdout);
  n = RD(), m = RD();
  for (unsigned i(1); i <= n; ++i) a[i] = RD();
  for (unsigned i(1); i <= n; ++i) b[i] = RDsg();
  for (unsigned i(1); i <= n; ++i) c[a[i]].push_back({i, b[i]});
  for (unsigned i(1); i <= m; ++i) {
    C = c[A = RD()].size(), D = c[B = RD()].size();
    unsigned Hei(n);
    long long Cur(0);
    memset(Sum, 0x3f, (n + 1) << 4);
    Sum[n] = 0, Ans = 0xafafafafafafafaf;
    for (unsigned j(0), k(0); j < C || k < D; ) {
      if((j ^ C) && ((k == D) || (c[A][j].first < c[B][k].first))) {
        Cur = Cur + c[A][j].second;
        Ans = max(Cur - Sum[Hei + 1], Ans);
        Sum[Hei + 1] = min(Sum[Hei] + c[A][j].second, Sum[Hei + 1]);
        ++Hei, ++j;
        continue;
      }
      if((k ^ D) && ((j == C) || (c[A][j].first > c[B][k].first))) {
        Cur = Cur + c[B][k].second;
        Ans = max(Cur - Sum[Hei - 1], Ans);
        Sum[Hei - 1] = min(Sum[Hei] + c[B][k].second, Sum[Hei - 1]);
        --Hei, ++k;
        continue;
      }
    }
    printf("%lld\n", Ans);
  }
  return 0;
}
//$2022NOIshandong&ShanXi
```

锅出在更新 `Sum` 数组上, 我使用的是

```cpp
...
Sum[Hei + 1] = min(Sum[Hei] + c[A][j].second, Sum[Hei + 1]);
...
Sum[Hei - 1] = min(Sum[Hei] + c[B][k].second, Sum[Hei - 1]);
...
```

这是用历史最低的值尝试更新这个历史最低的值, 但是真实情况是应该用当前值去更新这个历史最低值. 因此只要改成这样就正确了, 可以拿到 $20'$:

```cpp
...
Sum[Hei + 1] = min(Cur, Sum[Hei + 1]);
...
Sum[Hei - 1] = min(Cur, Sum[Hei - 1]);
...
```

这道题的正解是

### D1T2 进制转换

求 $Popcnt$ 有关的多项式, 显然线性是送的, 又因为是一个多项式的形式, 所以一眼出了 $y = 1$ 的做法, 就是倍增. 这就拿到了 $35'$.

如果要细说这个倍增的方法, 假设 $d < 3^k$, 我们考虑 $x^d z^{b_d}$, $x^{3^k + d} z^{b_{3^k + d}}$ 的关系, 发现 $x^{3^k + d} z^{b_{3^k + d}} = (x^d z^{b_d}) x^{3^k} z$, 以此类推 $x^{2 \times 3^k + d} z^{b_{2 \times 3^k + d}} = (x^d z^{b_d}) x^{2 \times 3^k} z^2$. 也就是说如果我们知道了 $\displaystyle{\sum_{i = 0}^{3^k - 1} x^dz^{b_d}}$, 那么我们就可以 $O(1)$ 求出 $\displaystyle{\sum_{i = 0}^{3^{k + 1} - 1} x^dz^{b_d}}$.

因此只需要 $\log_3 n$ 即可求出 $y = 1$ 的情况.

下面是考场 $35'$ 代码:

```cpp
#include <algorithm>
#include <bitset>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <unordered_map>
#include <vector>
using namespace std;
inline unsigned long long RD() {
  unsigned long long Rtmp(0);
  char Rch(getchar());
  while(Rch < '0' || Rch > '9') Rch = getchar();
  while(Rch >= '0' && Rch <= '9')
    Rtmp = Rtmp * 10 + Rch - '0', Rch = getchar();
  return Rtmp;
}
const unsigned long long Mod(998244353);
unsigned a[10000005], b[10000005];
unsigned long long n, m;
unsigned long long A, B, C[3], Ans(0);
inline unsigned long long Pow(unsigned long long x, unsigned long long y) {
  y %= 998244352, x %= Mod;
  unsigned long long Rt(1);
  while (y) {if(y & 1) Rt = Rt * x % Mod; x = x * x % Mod, y >>= 1;}
  return Rt;
}
inline unsigned PpC3 (unsigned long long x) {
  unsigned Rt(0);
  while (x) Rt += x % 3, x /= 3;
  return Rt;
}
signed main() {
  freopen("conversion.in", "r", stdin);
//  freopen("ex_conversion2.in", "r", stdin);
  freopen("conversion.out", "w", stdout);
  n = RD(), A = RD(), B = RD(), C[1] = RD();
  C[0] = 1, C[2] = C[1] * C[1] % Mod;
  a[0] = b[0] = 1;
  if(B == 1) {
    ++n;
    unsigned long long Tri[50], A3(A);
    Tri[0] = 1;
    for (unsigned long long i(3), j(1); i <= n; i *= 3, ++j) {
      unsigned long long Sec, Trd;
      Sec = (Tri[j - 1] * A3 % Mod) * C[1] % Mod;
      Trd = (Sec * A3 % Mod) * C[1] % Mod;
      Tri[j] = (Tri[j - 1] + Sec + Trd) % Mod;
      A3 = (A3 * A3 % Mod) * A3 % Mod;
    }
//    for (unsigned long long i(3), j(1); i <= n; i *= 3, ++j)
//      printf("%llu ", Tri[j]); putchar(0x0A);
    unsigned long long Cur(1);
    unsigned Lg(0), Rm(0);
    while (n) {
//      printf("n = %llu Cur %llu\n", n, Cur);
      if(Rm = ((n % (Cur * 3)) / Cur)) {
//        printf("Rm = %u\n", Rm);
        if(Rm ^ 1) {
          unsigned CP(PpC3(n / (Cur * 3)));
//          printf("CP %llu %u\n", n / (Cur * 3), CP); 
          Ans = (Ans + (Pow(A, n - Cur) * Tri[Lg] % Mod) * Pow(C[1], CP + 1)) % Mod;
          Ans = (Ans + (Pow(A, n - (Cur << 1)) * Tri[Lg] % Mod) * Pow(C[1], CP)) % Mod;
          n -= (Cur << 1);
        } else {
          unsigned long long CP(PpC3(n / (Cur * 3)));
//          printf("CP %llu %u\n", n / (Cur * 3), CP);
          Ans = (Ans + (Pow(A, n - Cur) * Tri[Lg] % Mod) * Pow(C[1], CP)) % Mod;
          n -= Cur;
        }
      }
      ++Lg, Cur *= 3;
    }
    printf("%llu\n", Ans - 1);
    return 0;
//    printf("%u\n")
  }
  if(n <= 10000000) {
//    Ans = 0;
//    printf("Excuseme %u\n", n);
    for (unsigned i(1), j(1); i <= n; ++i) {
      a[i] = (unsigned long long)a[i >> 1] * ((i & 1) ? B : 1) % Mod;
      b[i] = (unsigned long long)b[i / 3] * C[i % 3] % Mod;
      j = j * A % Mod;
      Ans = (Ans + ((unsigned long long)j * b[i] % Mod) * a[i]) % Mod;
    }
    printf("%llu\n", Ans);
    return 0;
  }
  return 0;
}
/*
100 1 1 2
10 2 1 1
8 2 1 2
9 2 1 2
10 2 1 2
100000001 123 1 12345
887397358
899868317
*/
```

接着考虑正解, 一开始想的是既然 $y = 1$ 是以 $3$ 为底的倍增, $z = 1$ 是以 $2$ 为底的倍增, 那么是否可以以 $6$ 为底进行倍增, 无果.

### D1T3 子串统计

一开始吧 $\prod$ 看成 $\sum$ 了, 导致了我以为一眼秒了, 对这个题有了一个大水题的第一印象, 所以 Day1 的大部分时间都是在 SAM 上疯狂 DP.

因为比赛前刚秒了几道字符串, 发现我简直是个字符串带师, 省选题又出现过那种题目难度完全和编排无关的情况, 所以我认为只要把 T3 做出来就能翻我 T1, T2 都不会的盘.

对于一个字串 $[l, r]$, 我们设它的出现次数是 $g_{l, r}$, 对答案的贡献是 $f_{l, r}$, 那么有式子:

$$
f_{l, r} = g_{l, r} (f_{l - 1, r} + f_{l, r + 1})
$$

可以用 SAM 求出所有的 $g$, 然后 $O(n^2)$ 算出所有的贡献, 最后答案遍是 $\displaystyle{\sum_{i = 1}^n f_{i, i}}$, 这个做法可以得到 $25'$.

其实还有一个做法, 就是用 SAM 上的节点进行 DP, 我们知道每个节点对应一系列的子串, 假设 $f_{i, j}$ 表示节点 $i$ 代表的, 长度为 $j$ 的子串所有出现位置的贡献之和. 那么我们可以把 SAM 拆成 $n^2$ 个节点, 使得每个节点只代表一个子串, 用 $f_{i}$ 表示每个节点的子串所有出现位置的贡献之和. 然后通过递归得到答案, 如果结合 `unordered_map` 进行记忆化搜索, 那么复杂度仍然是 $O(n^2)$ 的, 因为每个值只会被计算一遍.

这个做法比正常 $O(n^2)$ 慢不少, 感官上是过不了 $25'$ 的, 所以就是个废物, 用来验证正确性倒是可以, 但是场上这个做法相比上一种做法要麻烦很多, 所以每次两个做法答案不同都是这个做法出锅. 如果硬要给它找一个优点, 就是我们无需把所有点真的建出来, 所以可以在过大的数据中赶在 RE 或 MLE 之前 TLE.

下面是考场代码, 结合了上面两种做法, 期望仍为 $25'$:

```cpp
#include <algorithm>
#include <bitset>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <unordered_map>
#include <vector>
using namespace std;
inline unsigned RD() {
  unsigned Rtmp(0);
  char Rch(getchar());
  while(Rch < '0' || Rch > '9') Rch = getchar();
  while(Rch >= '0' && Rch <= '9')
    Rtmp = Rtmp * 10 + Rch - '0', Rch = getchar();
  return Rtmp;
}
inline int RDsg() {
  int Rtmp(0), Rsig(1);
  char Rch(getchar());
  while((Rch < '0' || Rch > '9') && (Rch ^ '-')) Rch = getchar();
  if(Rch == '-') Rsig = -1, Rch = getchar();
  while(Rch >= '0' && Rch <= '9')
    Rtmp = Rtmp * 10 + Rch - '0', Rch = getchar();
  return Rtmp * Rsig;
}
const unsigned long long Mod(998244353);
inline unsigned long long Pow(unsigned long long x, unsigned y) {
  unsigned long long Rt(1);
  while (y) {if(y & 1) Rt = Rt * x % Mod; x = x * x % Mod, y >>= 1;}
  return Rt;
}
char a[100005];
unsigned n, m;
unsigned A, B, C, D, t;
unsigned long long Ans(0);
struct Node {
  unordered_map<unsigned, unsigned> Mp;
  vector<Node*> Son;
  Node* E[26], *Link;
  unsigned Len, EndPos, Idg;
  inline void Add(char c);
  inline unsigned long long Get(unsigned x) {
    if(x == n) return 1;
    if(Mp[x]) return Mp[x];
    unsigned long long Bot(Pow(EndPos, Len - x));
    unsigned long long Rt(0);
    for (unsigned i(0); i < 26; ++i) if(E[i])
      Rt = (Rt + E[i]->Get(x + 1)) % Mod;
    if(Len == x) for (auto i:Son) Rt = (Rt + i->Get(Len + 1)) % Mod;
    else Rt += Get(x + 1);
//    printf("Find %u = %llu\n", x, Rt);
    return Mp[x] = (Rt * EndPos % Mod);
  }
  inline void DFS() {
    for (auto i:Son) i->DFS(), EndPos += i->EndPos;
  }
}N[200005], *List[100005], *CntN(N), *Last(N);
Node *Que[200005], **Hd(Que), **Tl(Que);
inline void Node::Add(char c) {
  Len = Last->Len + 1;
  Node* Back(Last);
  while (Back && (!Back->E[c])) Back->E[c] = this, Back = Back->Link;
  if(!Back) {Link = N, Last = this; return;}
  if(Back->E[c]->Len == Back->Len + 1) {
    Link = Back->E[c], Last = this;
    return;
  }
  Node *Ori(Back->E[c]), *Copy(++CntN);
  *Copy = *Ori, Copy->Len = Back->Len + 1;
  Ori->Link = Link = Copy, Last = this;
  while (Back && (Back->E[c] == Ori))
    Back->E[c] = Copy, Back = Back->Link;
  return;
}
signed main() {
  freopen("substring.in", "r", stdin);
//  freopen("ex_substring3.in", "r", stdin);
  freopen("substring.out", "w", stdout);
  scanf("%s", a + 1);
  n = strlen(a + 1);
  for (unsigned i(1); i <= n; ++i) (List[i] = ++CntN)->Add(a[i] - 'a');
  for (unsigned i(1); i <= n; ++i) List[i]->EndPos = 1;
//  printf("Link:");for (Node *i(N + 1); i <= CntN; ++i) printf("%u ", i->Link - N); putchar(0x0A);
  for (Node *i(N + 1); i <= CntN; ++i) i->Link->Son.push_back(i), ++(i->Idg);
  N->DFS();
//  printf("EndPos:");for (Node *i(N + 1); i <= CntN; ++i) printf("%u ", i->EndPos); putchar(0x0A);
  if(n <= 5000) {
    unsigned Apr[5005][5005];
    for (unsigned i(1), j(1); i <= n; j = ++i) {
      Node* Cur(List[i]);
      while (Cur) {
//        printf("i %u Cur %u j %u\n", i, Cur - N, j);
        unsigned LenMin(Cur->Link ? (Cur->Link->Len + 1) : 1);
        while (j >= LenMin) Apr[j][i - j + 1] = Cur->EndPos, --j;
        Cur = Cur->Link;
      }
    }
//    for (unsigned i(n); i; --i) {
//      for (unsigned j(n - i + 1); j; --j) printf("%3u", Apr[i][j]); putchar(0x0A);
//    }
    for (unsigned i(n - 1); i; --i) for (unsigned j(n - i + 1); j; --j)
      Apr[i][j] = (unsigned long long)Apr[i][j] * (Apr[i + 1][j] + Apr[i + 1][j - 1]) % Mod;
    for (unsigned j(1); j <= n; ++j) Ans += Apr[1][j];
//    for (unsigned i(n); i; --i) {
//      for (unsigned j(n - i + 1); j; --j) printf("%3u", Apr[i][j]); putchar(0x0A);
//    }
    printf("%llu\n", Ans % Mod);
    return 0;
  }
  Ans = 0;
  for (Node *i(N); i <= CntN; ++i)
      for (char j(0); j < 26; ++j) if(i->E[j]) ++(i->E[j]->Idg);
    *(++Tl) = N;
    while (Hd < Tl) {
      Node* Cur(*(++Hd));
      for (auto i:Cur->Son) if(!(--(i->Idg))) *(++Tl) = i;
      for (char i(0); i < 26; ++i) if(Cur->E[i])
        if(!(--(Cur->E[i]->Idg))) *(++Tl) = Cur->E[i];
    }
    /*for (unsigned i(1), j(1); i <= n; j = ++i) {
      Node* Cur(List[i]);
      while (Cur) {
  //    printf("i %u Cur %u j %u\n", i, Cur - N, j);
        unsigned LenMin(Cur->Link ? (Cur->Link->Len + 1) : 1);
        while (j >= LenMin) printf("%llu ", Cur->Get(j--));
        Cur = Cur->Link;
      }
      putchar(0x0A);
    }*/
//    for (unsigned i(1); i <= n; ++i) printf("%llu ", List[i]->Val); putchar(0x0A);
    for (char j(0); j < 26; ++j) if(N->E[j]) Ans += N->E[j]->Get(1);
    printf("%llu\n", Ans % Mod), Ans = 0;  
  return 0;
}
//$2022NOIshandong&ShanXi
```

### D2T1 小 N 的独立集

好歹是 A 了一道题, 这是继 CSP2021 T2, NOIP2021 T2 之后, 我场上 AC 的又一道数数题. (貌似这个题被认为是 SDOI2022 最简单的一道题)

出场后问了别人才发现, 其实很多人不知道树形背包的复杂度其实是 $O(nV)$ 的. 所以好多人都不敢去写这个正解.

我和别人有一点不同, 就是我做题的时候大部分时间答案都是错误的, 当我可以保证正确性的时候, 我就已经把这道题做到 $100'$ 了, 而很多 AC 本题的选手则是一开始保证正确性, 不断优化得到了正解.

```cpp
#include <algorithm>
#include <bitset>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <unordered_map>
#include <vector>
using namespace std;
inline unsigned RD() {
  unsigned Rtmp(0);
  char Rch(getchar());
  while(Rch < '0' || Rch > '9') Rch = getchar();
  while(Rch >= '0' && Rch <= '9')
    Rtmp = Rtmp * 10 + Rch - '0', Rch = getchar();
  return Rtmp;
}
inline int RDsg() {
  int Rtmp(0), Rsig(1);
  char Rch(getchar());
  while((Rch < '0' || Rch > '9') && (Rch ^ '-')) Rch = getchar();
  if(Rch == '-') Rsig = -1, Rch = getchar();
  while(Rch >= '0' && Rch <= '9')
    Rtmp = Rtmp * 10 + Rch - '0', Rch = getchar();
  return Rtmp * Rsig;
}
const unsigned long long Mod(1000000007);
unsigned n, m;
unsigned A, B, C, D, t;
struct Node {
  vector<Node*> E;
  unsigned f[5005][6], Size;
  inline void DFS(Node* Fa) {
    Size = m;
    if((E.size() == 1) && Fa) {
      for (unsigned i(1); i <= m; ++i) f[0][i] = 1;
      return;
    }
    for (auto i:E) if(i != Fa) i->DFS(this), Size += i->Size;
    unsigned Tmp[Size + 5][6], NoRoot[Size + 5], TNoR[Size + 5], Bot(0);
    unsigned MeL((Size + 5) << 2), MeB(MeL * 6), Cur(m);
    memset(NoRoot, 0, MeL);
    while (E[Bot] == Fa) ++Bot;
    memcpy(f, E[Bot]->f, MeB), Cur += E[Bot]->Size;
    for (int I(E.size() - 1); I > Bot; --I) if(E[I] != Fa) {
      Node* i(E[I]);
      memcpy(Tmp, f, MeB), memset(f, 0, MeB);
      memcpy(TNoR, NoRoot, MeL), memset(NoRoot, 0, MeL);
      unsigned *TTo, Mx, SMx;
      for (unsigned My(Cur); ~My; --My)
        for (unsigned Son(i->Size); ~Son; --Son) {
          for (unsigned k(m); ~k; --k)
            NoRoot[My + Son + k] = (NoRoot[My + Son + k] + (unsigned long long)TNoR[My] * i->f[Son][k]) % Mod;
          for (unsigned j(0); j <= m; ++j) for (unsigned k(0); k <= m; ++k) {
            if(j + k >= m) TTo = NoRoot + My + Son + j + k;
            else TTo = f[My + Son] + j + k;
            *TTo = (*TTo + (unsigned long long)Tmp[My][j] * i->f[Son][k]) % Mod;
          }
        }
      Cur += i->Size;
    }
    memcpy(Tmp, f, MeB);
    memset(f, 0, MeB);
    for (unsigned i(Size); ~i; --i) {
      f[i][0] = NoRoot[i] * (unsigned long long)m % Mod;
      for (unsigned j(0); j <= m; ++j) {
        f[i + j][0] = (f[i + j][0] + (unsigned long long)j * Tmp[i][j]) % Mod;
        for (unsigned k(j + 1); k <= m; ++k)
          f[i + j][k - j] = (f[i + j][k - j] + Tmp[i][j]) % Mod;
      }
    }
    char Flg(0);
    unsigned Ori(Size);
//    printf("Ori = %u\n", Size);
    while (!Flg) {
      for (unsigned i(0); i <= m; ++i) if(f[Size][i]) {Flg = 1; break;}
      if(!Flg) {
//        for (unsigned i(0); i <= m; ++i) printf("%u ", f[Size][i]); putchar(0x0A);
        --Size;
      }
    }
    Size += 5;
  }
}N[1005];
signed main() {
  freopen("nset.in", "r", stdin);
//  freopen("ex_nset2.in", "r", stdin);
  freopen("nset.out", "w", stdout);
  n = RD(), m = RD();
  for (unsigned i(1); i < n; ++i) {
    A = RD(), B = RD();
    N[A].E.push_back(N + B);
    N[B].E.push_back(N + A);
  }
  N[1].DFS(NULL);
  for (unsigned i(1); i <= n * m; ++i) {
    unsigned long long Ans(0);
    for (unsigned j(min(m, i)); ~j; --j) Ans += (i - j > N[1].Size) ? 0 : N[1].f[i - j][j];
    printf("%llu\n", Ans % Mod);
  }
  return 0;
}
//$2022NOIshandong&ShanXi
```

### D2T2 无处存储

刮痧题. 场上大部分选手们都刮了 $20'~50'$, 只有我只刮了 $10'$, 可能是因为递归原因, MLE 导致只拿到了 $2'$.

这两分就是只有 $3000$ 的那个点, 考场代码是这样的, 写了 $2\times 10^6$ 的单点修改, 单点查询但是没有过:

```cpp
#include <algorithm>
#include <bitset>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <unordered_map>
#include <vector>
#define Lbt(x) (((~(x))+1)&(x))
using namespace std;
inline unsigned RD() {
  unsigned Rtmp(0);
  char Rch(getchar());
  while(Rch < '0' || Rch > '9') Rch = getchar();
  while(Rch >= '0' && Rch <= '9')
    Rtmp = Rtmp * 10 + Rch - '0', Rch = getchar();
  return Rtmp;
}
inline int RDsg() {
  int Rtmp(0), Rsig(1);
  char Rch(getchar());
  while((Rch < '0' || Rch > '9') && (Rch ^ '-')) Rch = getchar();
  if(Rch == '-') Rsig = -1, Rch = getchar();
  while(Rch >= '0' && Rch <= '9')
    Rtmp = Rtmp * 10 + Rch - '0', Rch = getchar();
  return Rtmp * Rsig;
}
unsigned n, m;
unsigned A, B, C, D, Tmp(0);
unsigned Ans(0);
inline unsigned CalcV(unsigned x) {return x * (A * x + B) + C;}
unsigned Pre[1000005], Heavy[1000005], Cnt(0);
inline void Ins (unsigned x, unsigned y) {while (x <= n) Pre[x] += y, x += Lbt(x);}
inline void Qry (unsigned x) {Tmp = 0; while (x) Tmp += Pre[x], x -= Lbt(x);}
char FlgZ(0);
struct Node {
  vector<unsigned> Son;
  unsigned Fa, DFSr, Dep, Top;
}N[1000005];
inline unsigned DFS(unsigned x) {
  unsigned Size(1), CS(0), TS(0);
  for (auto i:N[x].Son) {
    N[i].Dep = N[x].Dep + 1, Size += (CS = DFS(i));
    if(TS < CS) TS = CS, Heavy[x] = i;
  }
  return Size;
}
inline void DFS2(unsigned x) {
  N[x].DFSr = ++Cnt;
  if(Heavy[x]) N[Heavy[x]].Top = N[x].Top, DFS2(Heavy[x]);
  for (auto i:N[x].Son) if(i != Heavy[x])N[i].Top = i, DFS2(i);
}
signed main() {
  freopen("problemprovidercreep.in", "r", stdin);
//  freopen("12.in", "r", stdin);
  freopen("problemprovidercreep.out", "w", stdout);
  A = RD();
  if(A == 31) FlgZ = 1;
  n = RD(), m = RD(), A = RD(), B = RD(), C = RD(), Heavy[0] = RD();
  for (unsigned i(2); i <= n; ++i) N[N[i].Fa = RD()].Son.push_back(i);
  N[1].Dep = 1, DFS(1), DFS2(1);
//  for (unsigned i(1); i <= n; ++i) printf("%u ", N[i].DFSr); putchar(0x0A);
  if(FlgZ) {
    for (unsigned i(1); i <= n; ++i) Heavy[N[i].DFSr] = CalcV(Heavy[N[i - 1].DFSr]);
    for (unsigned i(n); i >= 2; --i) Heavy[i] -= Heavy[i - 1];
    for (unsigned i(1); i <= n; ++i) Ins(i, Heavy[i]);
  }
  else {
    for (unsigned i(1); i <= n; ++i) Heavy[i] = CalcV(Heavy[i - 1]);
    for (unsigned i(1); i <= n; ++i) Ins(N[i].DFSr, Heavy[i]);
  }
  if(FlgZ) {
    for (unsigned i(1); i <= m; ++i) {
      Ans &= ((1 << 20) - 1);
      A = RD(), B = (RD() ^ Ans), C = (RD() ^ Ans);
      if(A) {
        Ans = 0;
        Qry(N[B].DFSr), Ans += Tmp;
        printf("%u\n", Ans);
      } else {
        D = (RD() ^ Ans);
        while (B && C && (N[B].Top ^ N[C].Top)) {
          if(N[N[B].Top].Dep < N[N[C].Top].Dep) swap(B, C);
          Ins(N[B].DFSr + 1, -D);
          Ins(N[N[B].Top].DFSr, D);
          B = N[N[B].Top].Fa;
        }
        if(N[B].Dep < N[C].Dep) swap(B, C);
        Ins(N[B].DFSr + 1, -D);
        Ins(N[C].DFSr, D);
      }
    }
    return 0;
  }
//  for (unsigned i(1); i <= n; ++i) printf("%u ", Heavy[i]); putchar(0x0A);
  for (unsigned i(1); i <= m; ++i) {
//    printf("Done %u\n", i);
    Ans &= ((1 << 20) - 1);
    A = RD(), B = (RD() ^ Ans), C = (RD() ^ Ans);
//    printf("%u To %u\n", B, C);
    if(A) {
      Ans = 0;
      while (B && C && (N[B].Top ^ N[C].Top)) {
        if(N[N[B].Top].Dep < N[N[C].Top].Dep) swap(B, C);
        Qry(N[B].DFSr), Ans += Tmp;
        Qry(N[N[B].Top].DFSr - 1), Ans -= Tmp;
        B = N[N[B].Top].Fa;
      }
//      printf("Jumped %u %u\n", B, C);
      if(N[B].Dep < N[C].Dep) swap(B, C);
      Qry(N[B].DFSr), Ans += Tmp;
      Qry(N[C].DFSr - 1), Ans -= Tmp;
//      printf("Tmp %u\n", Tmp);
      printf("%u\n", Ans);
    } else {
      D = (RD() ^ Ans);
      if(N[B].Dep < N[C].Dep) swap(B, C);
      while (N[B].Dep > N[C].Dep) Ins(N[B].DFSr, D), B = N[B].Fa;
      while (B ^ C)
        Ins(N[B].DFSr, D), Ins(N[C].DFSr, D), B = N[B].Fa, C = N[C].Fa;
      Ins(N[C].DFSr, D);
    }
  }
  return 0;
}
//$2022NOIshandong&ShanXi
```

### D2T3 多边形

其实当时写完 T1 先来干的是 T3, 写出了一个 $O(n^3)$ 的区间 DP, Hack 掉, 改 DP, 再 Hack. 其实问题的核心就是没法很好地断环为链, 所以心想再耗也不一定有结果, 不如去刮 T2.

所以这个题就摆烂了, 交了一个狗屁不通的代码上去:

```cpp
#include <algorithm>
#include <bitset>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <unordered_map>
#include <vector>
using namespace std;
inline unsigned RD() {
  unsigned Rtmp(0);
  char Rch(getchar());
  while(Rch < '0' || Rch > '9') Rch = getchar();
  while(Rch >= '0' && Rch <= '9')
    Rtmp = Rtmp * 10 + Rch - '0', Rch = getchar();
  return Rtmp;
}
inline int RDsg() {
  int Rtmp(0), Rsig(1);
  char Rch(getchar());
  while((Rch < '0' || Rch > '9') && (Rch ^ '-')) Rch = getchar();
  if(Rch == '-') Rsig = -1, Rch = getchar();
  while(Rch >= '0' && Rch <= '9')
    Rtmp = Rtmp * 10 + Rch - '0', Rch = getchar();
  return Rtmp * Rsig;
}
const unsigned long long Mod(998244353);
inline void Mn(unsigned &x) { x -= (x >= Mod) ? Mod : 0;}
unsigned f[5005][5005], a[500005];
unsigned n, m, Nom;
unsigned A, B, C, D, t;
signed main() {
  freopen("polygon.in", "r", stdin);
//  freopen("polygon1.in", "r", stdin);
  freopen("polygon.out", "w", stdout);
  n = RD(), a[m = 1] = 1;
  for (unsigned i(1); i <= n; ++i) {a[m += RD()] = 1;if(!Nom) Nom = m;} --m;
//  for (unsigned i(1); i <= m; ++i) printf("%u ", a[i]); putchar(0x0A);
  for (unsigned i(m - 2); i; --i) {
    unsigned j(i + 1);
    while (!a[j]) ++j; ++j;
    if(j > m) continue;
    do f[j - i][i] = 1; while (!a[j++]);
//    printf("Done %u\n", i);
  }
//  for (unsigned i(2); i < m; ++i) {
//    for (unsigned j(1); j + i <= m; ++j) printf("%3u", f[i][j]); putchar(0x0A);
//  }
//  printf("Done\n");
  for (unsigned i(2); i <= m - 2; ++i) {
    for (unsigned j(m - i); j; --j) {
      if(j + i < m) {
        unsigned k(j + i + 1);
        do Mn(f[k - j][j] += f[i][j]); while (!a[k++]);
      }
      if(j > 1) {
        unsigned l(j - 1);
        do Mn(f[i + j - l][l] += f[i][j]); while (!a[l--]);
      }
    }
  }
//  for (unsigned i(2); i < m; ++i) {
//    for (unsigned j(1); j + i <= m; ++j) printf("%3u", f[i][j]); putchar(0x0A);
//  }
  printf("%u\n", f[m - 1][1]);
  return 0;
}
//$2022NOIshandong&ShanXi
```