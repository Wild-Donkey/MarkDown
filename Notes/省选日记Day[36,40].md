# 省选日记 Day $36$ - Day $40$

## Day $36$ May 9, 2022, Monday

### [SDOI2019 移动金币](https://www.luogu.com.cn/problem/P5363)

发现这是一个典型的阶梯 NIM, 如果 $m$ 个金币把没有金币的空格分为 $m + 1$ 段, 那么后手必胜当且仅当从右往左数的偶数段的长度异或起来为零.

所以可以想到一个 $O(n^3m)$ 的算法, 也就是设 $f_{i, j, k}$ 表示如果 $j$ 个物品分成 $i$ 组, 异或和为 $k$ 的方案数. 那么答案便是:

$$
\sum_{i = 0}^{n - m} \binom{n - m - i + \lceil \frac{m + 1}2 \rceil - 1}{\lceil \frac{m + 1}2 \rceil - 1} f_{\lfloor \frac {m + 1}2 \rfloor, i, 0}
$$

转移也很简单:

$$
f_{i + 1, j + l, k \oplus l} += f_{i, j, k}
$$

这样可以得到 $50'$ 的好成绩.

```cpp
const unsigned long long Mod(1000000009);
inline void Mn(unsigned& x) { x -= ((x >= Mod) ? Mod : 0);}
inline unsigned long long Inver(unsigned long long x) {
  unsigned long long Rt(1);
  unsigned y(1000000007);
  while (y) { if(y & 1) Rt = Rt * x % Mod; x = x * x % Mod, y >>= 1; }
  return Rt;
}
unsigned Fac[150005], Inv[150005], f[255][255], g[255][255];
inline unsigned long long C(unsigned x, unsigned y) {
  return ((unsigned long long)Fac[x] * Inv[y] % Mod) * Inv[x - y] % Mod;
}
unsigned (*F)[255](f), (*G)[255](g), mm, m, n;
unsigned Cnt(0), Ans(0), Tmp(0);
signed main() {
  n = RD(), m = RD() + 1, mm = m >> 1, f[0][0] = Fac[0] = 1;
  for (unsigned long long i(1); i <= n; ++i) Fac[i] = Fac[i - 1] * i % Mod;
  Inv[n] = Inver(Fac[n]);
  for (unsigned long long i(n); i; --i) Inv[i - 1] = Inv[i] * i % Mod;
  n = n - m + 1;
  for (unsigned i(1); i <= mm; ++i) {
    swap(G, F);
    memset(F, 0, 260100);
    for (unsigned j(0); j <= n; ++j) for (unsigned k(0); k <= j; ++k)
      for (unsigned l(n - j); ~l; --l) Mn(F[j + l][k ^ l] += G[j][k]);
  }
  mm = m - mm - 1;
  for (unsigned i(0); i <= n; ++i) Ans = (Ans + F[i][0] * C(n - i + mm, mm)) % Mod;
  Ans = C(n + m - 1, m - 1) + Mod - Ans, Mn(Ans);
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

不过这道题作为 D2T3 有 $50'$ 白给相对这一年的染色来说已经友好多了.

看了一眼题解, 貌似是要按位考虑. 如果我们需要这些段异或和必须为 $0$, 那么充要条件是对于每一个二进制位, 它们的异或和为 $0$. 如果按位考虑那么情况会简单很多, 因为状态中总长度这一维会变成 $O(m)$, 异或值这一维可以根据总长度推算, 所以不用记.

重新设计 DP, 设 $g_{i, j, k}$ 表示考虑第 $i$ 位, 共 $j$ 段, 其中 $k$ 段为 $1$, 异或和为 $k \And 1$ 的方案数, 转移是这样的:

$$
g_{i, j + 1, k} += g_{i, j, k}\\
g_{i, j + 1, k + 1} += g_{i, j, k}\\
$$

$O(m^2\log n)$ 状态, $O(1)$ 转移, 复杂度 $O(m^2\log n)$.

发现 $g_{i, j, k}$ 就是一个二项式系数, 组合意义为从 $j$ 个物品中选 $k$ 个, 即 $\dbinom jk$.

改变 $f$ 的定义为 $f_{i, j}$ 表示仅考虑前 $i$ 位, 分成 $\lfloor \frac {m + 1}2 \rfloor$ 段, 总长度为 $2^{\lfloor \log n \rfloor - i}j$, 各位异或和为 $0$ 的方案数.

$$
f_{i + 1, 2j + 2k} += f_{i, j} * \binom{\lfloor \frac {m + 1}2 \rfloor}{2k}
$$

状态数 $O(n\log n)$, 转移 $O(m)$, 复杂度 $O(mn\log n)$.

统计答案是这样的, 仍然是 $O(n)$:

$$
\sum_{i = 0}^{n - m} \binom{n - m - i + \lceil \frac{m + 1}2 \rceil - 1}{\lceil \frac{m + 1}2 \rceil - 1} f_{\lfloor\log n\rfloor, i}
$$

```cpp
const unsigned long long Mod(1000000009);
inline void Mn(unsigned& x) { x -= ((x >= Mod) ? Mod : 0);}
inline unsigned long long Inver(unsigned long long x) {
  unsigned long long Rt(1);
  unsigned y(1000000007);
  while (y) { if(y & 1) Rt = Rt * x % Mod; x = x * x % Mod, y >>= 1; }
  return Rt;
}
unsigned Fac[150005], Inv[150005], f[20][150005], Bn[30][30];
inline unsigned long long C(unsigned x, unsigned y) {
  return ((unsigned long long)Fac[x] * Inv[y] % Mod) * Inv[x - y] % Mod;
}
unsigned mm, m, n, Lgn(0);
unsigned Cnt(0), Ans(0), Tmp(0);
signed main() {
  n = RD(), m = RD() + 1, mm = m >> 1, Bn[0][0] = f[0][0] = Fac[0] = 1;
  for (unsigned long long i(1); i <= n; ++i) Fac[i] = Fac[i - 1] * i % Mod;
  Inv[n] = Inver(Fac[n]);
  for (unsigned long long i(n); i; --i) Inv[i - 1] = Inv[i] * i % Mod;
  Tmp = n = n - m + 1;
  while (Tmp) Tmp >>= 1, ++Lgn; --Lgn;
  for (unsigned i(1); i <= mm; ++i) {
    Bn[i][0] = 1;
    for (unsigned j(1); j <= mm; ++j)
      Bn[i][j] = Bn[i - 1][j] + Bn[i - 1][j - 1], Mn(Bn[i][j]);
  }
  f[0][0] = 1;
  for (unsigned i(1); i <= Lgn; ++i) {
    unsigned N(n >> (Lgn - i)), N2(N >> 1);
    for (unsigned j(0); j <= N2; ++j)
      for (unsigned k(min(mm >> 1, N2 - j) << 1), *To(f[i] + (j << 1) + k); k < 0x3f3f3f3f; k -= 2, To -= 2)
        *To = (*To + (unsigned long long)f[i - 1][j] * Bn[mm][k]) % Mod;
  }
  mm = m - mm - 1;
  for (unsigned i(0); i <= n; ++i) Ans = (Ans + f[Lgn][i] * C(n - i + mm, mm)) % Mod;
  Ans = C(n + m - 1, m - 1) + Mod - Ans, Mn(Ans);
  printf("%u\n", Ans);
  return Wild_Donkey;
}
```

## Day $37$ May 10, 2022, Tuesday

### [SDOI2018 物理实验](https://www.luogu.com.cn/problem/P4605)

把给出的导轨变成 $x$ 轴, 将每个挡板都变成带权的线段, 权值就是一个单位宽度的激光会覆盖这个挡板的长度, 在导轨上方的挡板, 只有最低的部分有意义, 也就是说我们需要求出两个数组, 分别表示每个位置的导轨上方最低的挡板权值和导轨下方最高的挡板权值. 把两个数组每个位置对应相加得到一个数组 $a$. 我们需要找到 $a$ 的一个长为 $L$ 的子段使得这个段最大.

有一个贪心策略是我们选出的子段的左端点或右端点至少有一个是挡板端点的横坐标, 也就是说我们需要求 $O(n)$ 个区间的总和.

问题集中在了求出 $a$. 其实如果是较小的整数坐标的话可以用李超树求, 但是这时既是实数坐标有需要离散化, 所以不宜使用李超树. 发现一个非常重要的条件, 所有挡板不相交, 这蕴涵着一个信息, 如果用一条和 $y$ 轴平行的直线沿 $x$ 轴扫描, 所有和这条直线相交的线段的焦点的纵坐标相对关系不会改变, 由于我们只是希望知道相对关系, 所以可以只维护这个关系, 用平衡树实现.

旋转的方式每次都忘, 需要重新画图推导, $(x, y)$ 绕中心顺时针旋转 $\theta$ 后的坐标变成 $(y \sin \theta + x \cos \theta, y \cos \theta - x \sin \theta)$. (如果是逆时针则只要改变含有 $\sin \theta$ 的项的正负即可)

为了把导轨作为 $x$ 轴, 计算出导轨到原来原点的距离, 然后将所有点水平平移这个距离, 直线 $y = kx + b$ 到原点的距离为 $\sqrt{\dfrac{b^2}{1 + k^2}}$, 平移方向由导轨在原点上还是原点下决定, 也就是 $b$ 的正负, 也就是向下平移 $\dfrac b{\sqrt{1 + k^2}}$.

根据给出的导轨标准线段端点 $(x_1, y_1)$, $(x_2, y_2)$, 不失一般性, 设 $x_1 < x_2$. 可以直接求出 $\sin \theta$ 和 $\cos \theta$. 设标准线段的长度为 $Len$, 则 $\sin \theta = \dfrac {y_2 - y_1}{Len}$, $\cos \theta = \dfrac {x_2 - x_1}{Len}$.

虽然算法简单, 但是真的不好写. 而且据说卡精度需要 `long double`.
```cpp
const long double Ep(1e-12);
inline long double Squ (long double x) {return x * x;}
inline char Neq(long double x, long double y) {return (x + Ep < y) || (y + Ep < x); }
unsigned m, n, t;
unsigned Cnt(0), Tmp(0);
long double L, Sin, Cos, Move, Len, Scaning;
long double Ans;
struct Line {
  long double X1, X2, Y1, Y2, b, k, Val;
  inline void Rotate() {
    long double TmX, TmY;
    TmX = Y1 * Sin + X1 * Cos;
    TmY = Y1 * Cos - X1 * Sin - Move;
    X1 = TmX, Y1 = TmY;
    TmX = Y2 * Sin + X2 * Cos;
    TmY = Y2 * Cos - X2 * Sin - Move;
    X2 = TmX, Y2 = TmY;
    Val = sqrt((Squ(X2 - X1) + Squ(Y2 - Y1)) / Squ(X2 - X1));
    if(X1 > X2) swap(X1, X2), swap(Y1, Y2);
    k = (Y2 - Y1) / (X2 - X1), b = Y1 - (X1 * k);
  }
  inline void Prt() {
    printf("(%LF,%LF) (%LF,%LF) k %LF b %LF\n", X1, Y1, X2, Y2, k, b);
  }
  inline void Flip() {Y1 = -Y1, Y2 = -Y2, k = -k, b = -b;}
  inline long double Calc () const {return Scaning * k + b;}
  inline const char operator< (const Line& x) const{return Calc() < x.Calc();}
}Up[10005], Down[10005];
struct Range {
  long double Pos, Val;
  inline const char operator< (const Range& x) const{ return Pos < x.Pos;}
}UpR[20005], DownR[20005], Tot[40005];
struct Operate {
  long double Pos;
  Line* Val;
  char Type;
  inline const char operator< (const Operate& x) const{ return Pos < x.Pos;}
};
struct Node {
  Node* LS, * RS;
  Line* Mn, * Mx;
  unsigned Size;
  inline void Udt() {
    Size = LS->Size + RS->Size;
    Mn = LS->Mn, Mx = RS->Mx;
  }
  inline Node *Rotate() {
    if(!LS) return RS;
    if(!RS) return LS;
    if(Size <= 5) {if(LS) Udt(); return this;}
    if((LS->Size << 1) < RS->Size) {
      Node* Cur(RS);
      RS = Cur->RS, Cur->RS = Cur->LS, Cur->LS = LS, LS = Cur;
      Cur->Udt();
    }
    if((RS->Size << 1) < LS->Size) {
      Node* Cur(LS);
      LS = Cur->LS, Cur->LS = Cur->RS, Cur->RS = RS, RS = Cur;
      Cur->Udt();
    }
    Udt();
    return this;
  }
  inline Node *Insert(Line *x);
  inline Node *Delete(Line *x) {
    --Size;
    if((!LS) && (!RS)) { if(Mn != x) printf("Cao\n"); return NULL;}
    if(RS->Mn == x || *(RS->Mn) < *x) RS = RS->Delete(x);
    else LS = LS->Delete(x);
    return Rotate();
  }
}N[20005], *Root(N), *CntN(N);
inline Node* Node::Insert (Line *x) {
  ++Size;
  if((!LS) && (!RS)) {
    if((*Mn) < (*x)) Mx = x; else Mn = x;
    *(LS = ++CntN) = {NULL, NULL, Mn, Mn, 1};
    *(RS = ++CntN) = {NULL, NULL, Mx, Mx, 1};
    Udt();
    return this;
  }
  if(*(RS->Mn) < *x) RS = RS->Insert(x);
  else LS = LS->Insert(x);
  return Rotate();
}
inline void Build(Line* x, unsigned Lenx, Range* y, unsigned& Leny) {
  memset(N, 0, (CntN - N + 1) * sizeof(Node));
  Root = NULL, CntN = N, Leny = 0;
  Operate Op[Lenx << 1 + 2];
  for (unsigned i(1); i <= Lenx; ++i) {
    Op[(i << 1) - 1] = {x[i].X1, x + i, 0};
    Op[i << 1] = {x[i].X2, x + i, 1};
  }
  sort(Op + 1, Op + (Lenx = (Lenx << 1)) + 1);
  Scaning = -1e10;
  for (unsigned i(1); i <= Lenx; ++i) {
    long double Fill(0);
    if(Root && Root->Size) Fill = (Root->Mn)->Val;
    if(Neq(Scaning, Op[i].Pos) && (Scaning > -9e9)) y[++Leny] = {Scaning, Fill};
    Scaning = Op[i].Pos;
    if(Op[i].Type) Root = Root->Delete(Op[i].Val);
    else {
      if(!Root) *(Root = ++CntN) = {NULL, NULL, Op[i].Val, Op[i].Val, 1};
      else Root = Root->Insert(Op[i].Val);
    }
  }
  y[++Leny] = {Scaning, 0};
  return;
}
inline void Clr() {
  Ans = 0, n = RD();
}
signed main() {
  t = RD();
  for (unsigned T(1); T <= t; ++T){
    Clr();
    for (unsigned i(1); i <= n; ++i) {
      Up[i].X1 = RDsg(), Up[i].Y1 = RDsg();
      Up[i].X2 = RDsg(), Up[i].Y2 = RDsg();
    }
    long double Len, StanB, StanK, StanX1, StanY1, StanX2, StanY2;
    StanX1 = RDsg(), StanY1 = RDsg();
    StanX2 = RDsg(), StanY2 = RDsg();
    if(StanX1 > StanX2) swap(StanX1, StanX2), swap(StanY1, StanY2); 
    Len = sqrt(Squ(StanX2 - StanX1) + Squ(StanY2 - StanY1));
    Sin = (StanY2 - StanY1) / Len;
    Cos = (StanX2 - StanX1) / Len;
    StanK = (StanY2 - StanY1) / (StanX2 - StanX1);
    StanB = StanY1 - (StanX1 * StanK);
    Move = StanB / sqrt(1 + StanK * StanK);
    L = RD();
    unsigned Cntu(0), Cntd(0);
    for (unsigned i(1); i <= n; ++i) {
      Up[i].Rotate();
      if(Up[i].Y1 < 0) Down[++Cntd] = Up[i];
      else Up[++Cntu] = Up[i];
    }
    for (unsigned i(1); i <= Cntd; ++i) Down[i].Flip();
    Build(Up, Cntu, UpR, Cntu), Build(Down, Cntd, DownR, Cntd), n = 0;
    for (unsigned i(1), j(1); i <= Cntu || j <= Cntd;) {
      if(i > Cntu) {Tot[++n] = DownR[j++]; continue;}
      if(j > Cntd) {Tot[++n] = UpR[i++]; continue;}
      if(Neq(UpR[i].Pos, DownR[j].Pos)) {
        if(UpR[i].Pos < DownR[j].Pos) Tot[++n] = {UpR[i].Pos, UpR[i].Val + DownR[j - 1].Val}, ++i;
        else Tot[++n] = {DownR[j].Pos, DownR[j].Val + UpR[i - 1].Val}, ++j;
      } else Tot[++n] = {DownR[j].Pos, DownR[j].Val + UpR[i].Val}, ++j, ++i;
    }
    long double Cur(0);
    for (unsigned i(1), j(1); i < n; ++i) {
      while ((j < n) && (Tot[j + 1].Pos - Tot[i].Pos <= L)) 
        Cur += Tot[j].Val * (Tot[j + 1].Pos - Tot[j].Pos), ++j;
      Ans = max(Ans, Cur + (L - Tot[j].Pos + Tot[i].Pos) * Tot[j].Val);
      Cur -= Tot[i].Val * (Tot[i + 1].Pos - Tot[i].Pos);
    }
    Cur = 0;
    for (unsigned i(n), j(n); j > 1; --j) {
      while ((i > 1) && (Tot[j].Pos - Tot[i - 1].Pos <= L)) 
        Cur += Tot[i - 1].Val * (Tot[i].Pos - Tot[i - 1].Pos), --i;
      Ans = max(Ans, Cur + (L - Tot[j].Pos + Tot[i].Pos) * Tot[i - 1].Val);
      Cur -= Tot[j - 1].Val * (Tot[j].Pos - Tot[j - 1].Pos);
    }
    printf("%.10LF\n", Ans);
  }
  return Wild_Donkey;
}
```