# ybt1328 光荣的梦想

## 【题目描述】

Prince对他在这片大陆上维护的秩序感到满意，于是决定启程离开艾泽拉斯。在他动身之前，Prince决定赋予King_Bette最强大的能量以守护世界、保卫这里的平衡与和谐。在那个时代，平衡是个梦想。因为有很多奇异的物种拥有各种不稳定的能量，平衡瞬间即被打破。KB决定求助于你，帮助他完成这个梦想。

一串数列即表示一个世界的状态。

平衡是指这串数列以升序排列。而从一串无序数列到有序数列需要通过交换数列中的元素来实现。KB的能量只能交换相邻两个数字。他想知道他最少需要交换几次就能使数列有序。

## 【输入】

第一行为数列中数的个数n,第二行为n ≤ 10000个数。表示当前数列的状态。

## 【输出】

输出一个整数，表示最少需要交换几次能达到平衡状态。

## 【输入样例】

```
4 2 1 4 3
```

##【输出样例】

```
2
```

## 【题解】

因为交换的最后结果都是一样的(递增序列).所以就可以先从得到最后的序列的方法入手.

众所周知,将无序序列变成有序序列的方法是排序.

然而首选的sort()在这里没法用,因为是黑箱操作,所以不采用.

这时就能想到另一个效率高的,便于操作的排序方式:归并.

归并的思想就是分治,先将序列一分为二,分别排好两边,然后有序O(n)合并.

再来分析题目,由于要用交换的方式来得到答案,所以就可以得到一个推论:

只要交换出现的所有逆序对,就可以得到有序序列.(逆序对就是后面的j元素比前面的i元素大,那么i,j就是逆序对)(如果一个数在多个逆序对中出现,那么将其从离次数最近的数开始,一直交换过去,直到和离此数最远的数交换)

在两半序列都为有序的情况下,若i在左序列,j在右序列,那么只要i>j,那么在左序列中,i右边的所有数也大于j.

那么就可以再找到i时,直接给答案加上符合逆序对的元素数,然后再继续找即可.

说的很不清楚,还是代码明白:

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
long long a[10005],t[10005],ans=0, n, k;
void Merge(int l, int r) {
	if (l == r)
		return;
	int m = (l + r) / 2, i = l, j = m + 1, k = l;
	Merge(l, m);//排好左边
	Merge(m + 1, r);//排好右边
	while (i <= m && j <= r) {
		if (a[i] <= a[j]) {//左边的i比右边的j小(或等于),无需交换
			t[k++] = a[i++];
		}
		else {//右边的j比左边的i小(当然也比左区间内i右边的数小),需要交换
			t[k++] = a[j++];
			ans += m - i + 1;//这就是左区间中所有比j大的点,都要交换(因为右边序列是此时有序的,所以右边序列)
		}
	}
	while (i <= m) {
		t[k++] = a[i++];
	}
	while (j <= r) {
		t[k++] = a[j++];
	}
	for (int b = l; b <= r; b++) {
		a[b] = t[b];
	}
	return;
}
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	Merge(1, n);
	printf("%d\n", ans);
	return 0;
}
```

