<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Wild_Donkey
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="Wild_Donkey" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head>
    
		<!-- Layouts -->



              <!--  代码渲染  -->
              <link rel="stylesheet" href="/css/prism_coy.css" />
              <link rel="stylesheet" href="/css/typo.css" />
              <!-- 文章页 -->

              <body class>
                <!-- Wrapper 外包 s-->
                <div id="wrapper" class="fade-in">
                  <!-- Intro 头部显示 s -->
                  <!-- Intro 头部显示 e -->
                  <!-- Header 头部logo start -->
                  <header id="header">
    <a href="/" class="logo">Think Different</a>
</header>
                    <!-- Nav 导航条 start -->
                    <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">Categories</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Contests/">Contests</a></li><li><a class="category-link" href="/categories/Engineering/">Engineering</a></li><li><a class="category-link" href="/categories/Essays/">Essays</a></li><li><a class="category-link" href="/categories/Mathematics/">Mathematics</a></li><li><a class="category-link" href="/categories/Notes/">Notes</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        <li class="active">
	            <a href="#s1">Archives</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="archive-link" href="/archives/2022/08/">August 2022</a></li><li><a class="archive-link" href="/archives/2022/07/">July 2022</a></li><li><a class="archive-link" href="/archives/2022/06/">June 2022</a></li><li><a class="archive-link" href="/archives/2022/05/">May 2022</a></li><li><a class="archive-link" href="/archives/2022/04/">April 2022</a></li><li><a class="archive-link" href="/archives/2022/03/">March 2022</a></li><li><a class="archive-link" href="/archives/2022/02/">February 2022</a></li><li><a class="archive-link" href="/archives/2022/01/">January 2022</a></li><li><a class="archive-link" href="/archives/2021/11/">November 2021</a></li><li><a class="archive-link" href="/archives/2021/10/">October 2021</a></li><li><a class="archive-link" href="/archives/2021/08/">August 2021</a></li><li><a class="archive-link" href="/archives/2020/11/">November 2020</a>
	                    </ul>
	        </li>
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="About">
		                About
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="Friends">
		                Friends
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="Gallery">
		                Gallery
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="Tags">
		                Tags
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/Wild-Donkey" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

                      <div id="main">
                        <div class="post_page_title_img"
                          style="height: 25rem;background-image: url(https://wild-donkey-gallery.oss-cn-hangzhou.aliyuncs.com/BlogImg/Photo4.JPG);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                          <a href="#" style="padding: 4rem 4rem 2rem 4rem ;">
                            <h2>
                              随机游走变换
                            </h2>
                          </a>
                        </div>
                        <!-- Post -->
                        <div class="typo" style="padding: 3rem;">
                          <h1 id="再探傅里叶变换"><a class="markdownIt-Anchor" href="#再探傅里叶变换"></a> 再探傅里叶变换</h1>
<h2 id="从离散傅里叶变换到随机游走变换"><a class="markdownIt-Anchor" href="#从离散傅里叶变换到随机游走变换"></a> 从离散傅里叶变换到随机游走变换</h2>
<blockquote>
<p>一个优美的假做法罢了 ----Wild_Donkey</p>
</blockquote>
<h2 id="前置知识"><a class="markdownIt-Anchor" href="#前置知识"></a> 前置知识</h2>
<p><a href="/Mathematics/Polynomial/Convolution">离散傅里叶变换</a></p>
<h2 id="灵感-量子通信"><a class="markdownIt-Anchor" href="#灵感-量子通信"></a> 灵感: <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7738">量子通信</a></h2>
<p>题意是给一堆 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>256</mn></mrow><annotation encoding="application/x-tex">256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span></span> 位的二进制串, 我们称其为单词. 给出的单词组成一个字典, 每次询问给一个单词, 输出它是否可以取反至多 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 位后得到一个字典内的单词. 这个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 不大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>.</p>
<p>我一上来就发现, 因为序列进行离散傅里叶变换之后的函数的每一个点值都是根据整个序列的每一个位置的值求出来的, 所以当两个序列长得很像的时候, 他们离散傅里叶变换之后的点值被认为是差别不大的. 更好的性质是, 本题字典是通过给出的生成器随机生成的, 可以考虑非确定性算法. 所以我最初的想法是这样的:</p>
<p>把字典里的所有序列拿出来, 进行离散傅里叶变换, 对于每个频率建一个复平面, 每个单词在这个频率的变换后的点值在这个复平面里是一个点. 每次询问, 在每个复平面里找到询问串的坐标, 然后判断这个坐标附近的点对应的单词和询问串相差几位. 实现上在复平面里找欧氏距离最短的几个点很困难, 所以我们选择取某一维相近的点, 控制这个参数 有几个可控的参数, 比如我们不用判断所有复平面, 可以选择部分复平面, 所以选择的复平面数量可以控制. 我们还可以控制每个复平面判断多少个点. 通过调参可以找到准确率和效率之间的平衡.</p>
<p>我选择的是选择最后两个复平面, 各判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>200</mn></mrow><annotation encoding="application/x-tex">200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 个点, 可以得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 分, 下面是代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Pie</span><span class="params">(<span class="number">3.141592653589793238462643383279502884197169399</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> HexList[<span class="number">17</span>] = <span class="string">&quot;084C2A6E195D3B7F&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">Debug</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> Pp[<span class="number">65536</span>], Hex[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mn</span><span class="params">(<span class="type">unsigned</span>&amp; x)</span> </span>&#123; x -= ((x &gt;= <span class="number">256</span>) ? <span class="number">256</span> : <span class="number">0</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">double</span> <span class="title">Sqr</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">myRand</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&amp; k1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&amp; k2)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">k3</span><span class="params">(k1)</span>, <span class="title">k4</span><span class="params">(k2)</span></span>;</span><br><span class="line">  k1 = k4;</span><br><span class="line">  k3 ^= (k3 &lt;&lt; <span class="number">23</span>);</span><br><span class="line">  k2 = k3 ^ k4 ^ (k3 &gt;&gt; <span class="number">17</span>) ^ (k4 &gt;&gt; <span class="number">26</span>);</span><br><span class="line">  <span class="keyword">return</span> k2 + k4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="title">PopC</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Debug) <span class="built_in">printf</span>(<span class="string">&quot;Popc %llu\n&quot;</span>, x);</span><br><span class="line">  <span class="keyword">return</span> Pp[x &gt;&gt; <span class="number">48</span>] + Pp[(x &gt;&gt; <span class="number">32</span>) &amp; <span class="number">65535</span>] + Pp[(x &gt;&gt; <span class="number">16</span>) &amp; <span class="number">65535</span>] +</span><br><span class="line">         Pp[x &amp; <span class="number">65535</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Comp</span> &#123;</span><br><span class="line">  <span class="type">double</span> Rel, Vir;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">const</span> Comp <span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">double</span>&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;Rel + x, Vir&#125;; &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">const</span> Comp <span class="keyword">operator</span>-(<span class="type">const</span> <span class="type">double</span>&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;Rel - x, Vir&#125;; &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">const</span> Comp <span class="keyword">operator</span>*(<span class="type">const</span> <span class="type">double</span>&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;Rel * x, Vir * x&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">const</span> Comp <span class="keyword">operator</span>/(<span class="type">const</span> <span class="type">double</span>&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;Rel / x, Vir / x&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">double</span>&amp; x) &#123; Rel += x; &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span>-=(<span class="type">const</span> <span class="type">double</span>&amp; x) &#123; Rel -= x; &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span>*=(<span class="type">const</span> <span class="type">double</span>&amp; x) &#123; Rel *= x, Vir *= x; &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span>/=(<span class="type">const</span> <span class="type">double</span>&amp; x) &#123; Rel /= x, Vir /= x; &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">const</span> Comp <span class="keyword">operator</span>+(<span class="type">const</span> Comp&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;Rel + x.Rel, Vir + x.Vir&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">const</span> Comp <span class="keyword">operator</span>-(<span class="type">const</span> Comp&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;Rel - x.Rel, Vir - x.Vir&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">const</span> Comp <span class="keyword">operator</span>*(<span class="type">const</span> Comp&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;x.Rel * Rel - x.Vir * Vir, x.Rel * Vir + x.Vir * Rel&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">const</span> Comp <span class="keyword">operator</span>/(<span class="type">const</span> Comp&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">double</span> <span class="title">Mother</span><span class="params">(Sqr(x.Rel) + Sqr(x.Vir))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> Comp&#123;(x.Rel * Rel + x.Vir * Vir), (x.Vir * Rel - x.Rel * Vir)&#125; /</span><br><span class="line">           Mother;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Comp&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> Rel &lt; x.Rel; &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span>+=(<span class="type">const</span> Comp&amp; x) &#123; Rel += x.Rel, Vir += x.Vir; &#125;</span><br><span class="line">&#125; W[<span class="number">256</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> A, B;</span><br><span class="line"><span class="type">char</span> a[<span class="number">256</span>], <span class="built_in">Flg</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">unsigned</span> n, m;</span><br><span class="line"><span class="type">unsigned</span> C, D, t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Word</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> Val[<span class="number">4</span>];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a), C = <span class="built_in">RD</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">63</span>); ~i; --i) Val[i &gt;&gt; <span class="number">4</span>] &lt;&lt;= <span class="number">4</span>, Val[i &gt;&gt; <span class="number">4</span>] |= Hex[a[i]];</span><br><span class="line">    <span class="keyword">if</span> (Flg)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">4</span>; ++i) Val[i] ^= <span class="number">0xFFFFFFFFFFFFFFFF</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">256</span>; ++i) a[i] = ((Val[i &gt;&gt; <span class="number">6</span>] &gt;&gt; (i &amp; <span class="number">63</span>)) &amp; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="title">Diff</span><span class="params">(<span class="type">const</span> Word&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">Rt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">4</span>; ++i) Rt += <span class="built_in">PopC</span>(Val[i] ^ x.Val[i]);</span><br><span class="line">    <span class="keyword">return</span> Rt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Wd[<span class="number">400005</span>], Q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Plane</span> &#123;</span><br><span class="line">  pair&lt;Comp, <span class="type">unsigned</span>&gt; Pnt[<span class="number">400005</span>];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;(%lf,%lf) %u\n&quot;</span>, Pnt[i].first.Rel, Pnt[i].first.Vir,</span><br><span class="line">             Pnt[i].second);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123; <span class="built_in">sort</span>(Pnt + <span class="number">1</span>, Pnt + n + <span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">Find</span><span class="params">(Comp x, Word&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> L, R;</span><br><span class="line">    <span class="function">pair&lt;Comp, <span class="type">unsigned</span>&gt; <span class="title">Fd</span><span class="params">(&#123;x, <span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">    L = <span class="built_in">lower_bound</span>(Pnt + <span class="number">1</span>, Pnt + n + <span class="number">1</span>, Fd) - Pnt;</span><br><span class="line">    R = <span class="built_in">min</span>(L + <span class="number">100</span>, n), L = ((L &lt;= <span class="number">100</span>) ? <span class="number">1</span> : (L - <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(L); i &lt;= R; ++i)</span><br><span class="line">      <span class="keyword">if</span> (y.<span class="built_in">Diff</span>(Wd[Pnt[i].second]) &lt;= C) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; P[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Comp <span class="title">DFT</span><span class="params">(<span class="type">unsigned</span> Fre, <span class="type">char</span>* Ori)</span> </span>&#123;</span><br><span class="line">  Comp Rt;</span><br><span class="line">  Rt = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>), <span class="built_in">j</span>(<span class="number">0</span>); i &lt; <span class="number">256</span>; ++i, <span class="built_in">Mn</span>(j += Fre))</span><br><span class="line">    <span class="keyword">if</span> (Ori[i]) Rt += W[j];</span><br><span class="line">  <span class="keyword">return</span> Rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">Cnt</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">Tmp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">65536</span>; ++i) Pp[i] = Pp[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">16</span>; ++i) Hex[HexList[i]] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">    W[i] = &#123;<span class="built_in">cos</span>(i * Pie / <span class="number">128</span>), <span class="built_in">sin</span>(i * Pie / <span class="number">128</span>)&#125;;</span><br><span class="line">  n = <span class="built_in">RD</span>(), m = <span class="built_in">RD</span>(), A = <span class="built_in">RDll</span>(), B = <span class="built_in">RDll</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt; <span class="number">256</span>; ++j)</span><br><span class="line">      a[j] = (<span class="built_in">myRand</span>(A, B) &amp; ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">32</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">255</span>); ~j; --j)</span><br><span class="line">      Wd[i].Val[j &gt;&gt; <span class="number">6</span>] &lt;&lt;= <span class="number">1</span>, Wd[i].Val[j &gt;&gt; <span class="number">6</span>] |= a[j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt; <span class="number">2</span>; ++j) P[j].Pnt[i] = &#123;<span class="built_in">DFT</span>(<span class="number">255</span> - j, a), i&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">2</span>; ++i) P[i].<span class="built_in">Init</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= m; ++i) &#123;</span><br><span class="line">    Q.<span class="built_in">Rd</span>(), Flg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt; <span class="number">2</span>; ++j)</span><br><span class="line">      <span class="keyword">if</span> (P[j].<span class="built_in">Find</span>(<span class="built_in">DFT</span>(<span class="number">255</span> - j, a), Q)) &#123;</span><br><span class="line">        Flg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, Flg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Wild_Donkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重回傅里叶"><a class="markdownIt-Anchor" href="#重回傅里叶"></a> 重回傅里叶</h2>
<p>我们发现求离散傅里叶变换的点值的函数就是把一些单位向量加起来得到的和向量, 这是因为傅里叶变换是由积分定义的, 而离散时间傅里叶变换是由加和式定义的, 而加和的每一个元素都是一个由所求的频率和取样时间决定辐角的单位向量和取样处函数值的乘积.</p>
<p>我们重新审视傅里叶变换定义式:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>f</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>ξ</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>π</mi><mi>i</mi><mi>x</mi><mi>ξ</mi></mrow></msup><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\hat f(\xi) = \int_{-\infin}^{+\infin} f(x) e^{-2\pi ix\xi}dx
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2078799999999998em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.08332999999999999em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04601em;">ξ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.491512em;vertical-align:-0.970281em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5212310000000002em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.970281em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight" style="margin-right:0.04601em;">ξ</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></span></p>
<p>先假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 是一个定义域和值域都是实数的函数, 如果我们定义一个极坐标方程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mo>−</mo><mfrac><mi>θ</mi><mi>ξ</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(\theta) = f(-\frac {\theta}{\xi})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04601em;">ξ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>, 会发现这个方程的图像就是把函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的图像按每圈 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>ξ</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac {1}{\xi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04601em;">ξ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的速度, 顺时针缠绕在原点上, 比如原图像上的点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, f(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>, 在极坐标系中映射到的就是点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mi>ξ</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mi>ξ</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\cos(-x\xi)f(x), \sin(-x\xi)f(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mop">cos</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.04601em;">ξ</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.04601em;">ξ</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>, 如果我们把坐标当成复数, 则这个点就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>π</mi><mi>i</mi><mi>x</mi><mi>ξ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">f(x)e^{-2\pi ix\xi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight" style="margin-right:0.04601em;">ξ</span></span></span></span></span></span></span></span></span></span></span></span>. 这样就可以把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的值域推广到复数了.</p>
<p>定义一个定义域为实数, 值域为复数的函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>π</mi><mi>i</mi><mi>x</mi><mi>ξ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">g(x) = f(x)e^{-2\pi ix\xi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight" style="margin-right:0.04601em;">ξ</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>发现了什么, 我们傅里叶变换所求的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>f</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1523199999999998em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.08332999999999999em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ξ</mi></mrow><annotation encoding="application/x-tex">\xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.04601em;">ξ</span></span></span></span> 处的点值, 也就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 的积分. 这个值的几何意义是把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 用这种方式映射到复平面上得到的曲线的重心所对应的复数乘以积分区间的长度在积分区间趋于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-\infin, +\infin]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">]</span></span></span></span> 的极限.</p>
<p>为什么说是极限呢, 我们考虑在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 取值非零的区间长度是有限的, 而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的定义域区间长度趋于无限, 因此重心的模长是一个极小值. 又因为积分区间的长度取一个极大值, 所以二者的乘积只能求一个极限, 而无法计算确切的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>×</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">0 \times \infin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span>.</p>
<p>这样我们就知道了为什么傅里叶变换可以完美地分离出特定频率的信号. 因为对于频率不是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ξ</mi></mrow><annotation encoding="application/x-tex">\xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.04601em;">ξ</span></span></span></span> 的信号, 它以每圈 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>ξ</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac 1{\xi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04601em;">ξ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 缠绕在原点上, 每个角度上每次缠绕上的函数值的平均值的期望是相同的, 也就是说当取样长度趋于无穷时, 相当于每个角度都有相同长度的向量加和, 结果当然是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>. 这就代表了这些信号在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∫</mo><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>π</mi><mi>i</mi><mi>x</mi><mi>ξ</mi></mrow></msup><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_{-\infin}^{+\infin} f(x) e^{-2\pi ix\xi}dx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.380382em;vertical-align:-0.41415100000000005em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9662310000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.41415100000000005em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight" style="margin-right:0.04601em;">ξ</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span> 里, 其贡献是趋于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的, 注意这里是对积分结果的贡献趋于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 而不是对重心模长贡献趋于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>. 因此只要积分区间足够长, 那么频率不是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ξ</mi></mrow><annotation encoding="application/x-tex">\xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.04601em;">ξ</span></span></span></span> 的信号对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>f</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>ξ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat f(\xi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2078799999999998em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.08332999999999999em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04601em;">ξ</span><span class="mclose">)</span></span></span></span> 的影响就足够小.</p>
<p>我们考虑在时间上离散取样, 这样就可以把积分变成加和, 这就是离散时间傅里叶变换:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>f</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>ξ</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>x</mi><mo>=</mo><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><mrow><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></munderover><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>π</mi><mi>i</mi><mi>x</mi><mi>ξ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\hat f(\xi) = \sum_{x = -\infin}^{+\infin} f(x) e^{-2\pi ix\xi}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2078799999999998em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.08332999999999999em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04601em;">ξ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0666720000000005em;vertical-align:-1.308336em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7583360000000003em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">=</span><span class="mord mtight">−</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.308336em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight" style="margin-right:0.04601em;">ξ</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>其理论和傅里叶变换一样, 只是用取样代替了难以处理的积分. 然后重新审视我们针对本题的离散时间傅里叶变换式子, 会发现因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 的值只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 两种:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>f</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>ξ</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><mn>255</mn></munderover><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>π</mi><mi>i</mi><mi>x</mi><mi>ξ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\hat f(\xi) = \sum_{x = 0}^{255} [a[x]]e^{-2\pi ix\xi}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2078799999999998em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.08332999999999999em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04601em;">ξ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.068226em;vertical-align:-1.267113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">5</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mclose">]</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight" style="margin-right:0.04601em;">ξ</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="做法的原理"><a class="markdownIt-Anchor" href="#做法的原理"></a> 做法的原理</h2>
<p>这里有一个结论, 在平面上从原点开始, 每次随机选择方向, 走单位向量, 随机游走 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 步的终点的期望模长是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span> 的.</p>
<p>也就是说, 二进制串 <code>a</code> 的每一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>, 都对应了一个单位向量被累加到结果中, 那么这个结果最后的落点模长的最大值就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>256</mn></mrow><annotation encoding="application/x-tex">256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span></span>, 而整个复平面. 在频率很高的时候, 辐角的选择就渐渐失去规律了, 我们可以大概地认为这是在平面里随机游走, 加上这个串是随机生成的, 也就是说它的 Popcount 的期望是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span>, 因此我们可以认为它的结果的模长期望是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><msqrt><mn>2</mn></msqrt></mrow><annotation encoding="application/x-tex">8\sqrt 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord">8</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;">2</span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span>, 实际可能要更小, 因为它是每个 Popcount 的出现概率是二项分布的, 我们根据这个概率乘以对应的 Popcount 的根号值, 而根号函数是增长越来越慢的.</p>
<p>我们继续考虑一个串的某些位取反对离散傅里叶变换结果的影响. 我们知道傅里叶变换是线性变换, 所以如果改变 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 位, 相当于从原来的值的基础上再随机游走 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 步, 变化前后的结果在复平面上的距离不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>, 也就是说我们把搜索范围从所有点确定性地缩小到了直径 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 的圆内.</p>
<p>如果根据那个随机游走的结论, 那么我们可以只查询更小范围的临近点, 就可以在很大几率上找到要找的点. 假设可以快速找到临近半径为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 的点, 那么就可以有接近一半的几率找到目标点. 我们多找几个复平面, 就可以把找不到的概率降到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">1\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">%</span></span></span></span> 以下. 当然这个准确率还是不足以 AC 的. 但是如果取反的位数少一些, 准确率就会大大升高, 甚至可以得到确定性算法.</p>
<p>因为本题询问过多, 所以准确率要经受住 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> 次考验才能通过一个测试点, 这要求准确率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">x^{10^5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869199999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight"><span class="mord mtight">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 也是一个非常高的概率才可以, 这无疑是困难的, 因为我们最多进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>256</mn></mrow><annotation encoding="application/x-tex">256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span></span> 次指数放大, 但是需要进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span> 次指数缩小. 因此出现两条路: 要么增加指数放大次数, 要么用确定性算法.</p>
<h2 id="改进"><a class="markdownIt-Anchor" href="#改进"></a> 改进</h2>
<p>首先因为我们利用的是离散时间傅里叶变换随机游走的性质, 因此可以把傅里叶变换直接改成随机游走, 每个复平面定义一个随机的辐角序列, 规定每一位的单位向量的辐角. 这样不仅可以使得假随机更加随机, 还可以使得复平面数更多, 增加指数放大的次数.</p>
<p>接下来我们又发现对于找临近点我的处理方式是非常粗放的, 只是把横坐标相近的点拿出来, 相当于是复平面上取了一个长条. 其实为了更有效地找临近的点, 可以给复平面分块. 但是因为点的分部是辐射对称的, 所以我们不像一般的平面分块, 把横纵坐标分别分成根号段, 而是分别把辐角和模长分别分为根号段, 每次取这个段里面的点拿来比较, 这样甚至不用存储每个点的具体坐标, 提升了效率.</p>
<p>因为没有查阅到相关记载, 所以我们把这种判断方式称为 “随机游走变换” (Random Wandering Transform), 简称 RWT.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> <span class="title">Pie</span><span class="params">(<span class="number">3.141592653589793238462643383279502884197169399</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">unsigned</span> <span class="title">Num</span><span class="params">(<span class="number">6</span>)</span>, <span class="title">Side</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> HexList[<span class="number">17</span>] = <span class="string">&quot;084C2A6E195D3B7F&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> A, B;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">Blc</span><span class="params">(<span class="number">1</span>)</span>, BlcLen[512]</span>;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">Debug</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> Pp[<span class="number">65536</span>], Hex[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">myRand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">k3</span><span class="params">(A)</span>, <span class="title">k4</span><span class="params">(B)</span></span>;</span><br><span class="line">  A = k4, k3 ^= (k3 &lt;&lt; <span class="number">23</span>);</span><br><span class="line">  B = k3 ^ k4 ^ (k3 &gt;&gt; <span class="number">17</span>) ^ (k4 &gt;&gt; <span class="number">26</span>);</span><br><span class="line">  <span class="keyword">return</span> B + k4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">RandomAng</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ((<span class="built_in">myRand</span>() % <span class="number">1048576</span>) * Pie) / <span class="number">524288</span>; &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Comp</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Angle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Rt</span><span class="params">(atan(Vir / Rel))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> Rt + ((Vir &lt; <span class="number">0</span>) ? Pie : ((Rel &lt; <span class="number">0</span>) ? (Pie * <span class="number">2</span>) : <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Model</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">Sqr</span>(Vir) + <span class="built_in">Sqr</span>(Rel)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> a[<span class="number">256</span>], <span class="built_in">Flg</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">unsigned</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Build</span><span class="params">(<span class="type">unsigned</span> L, <span class="type">unsigned</span> R, <span class="type">unsigned</span> x, <span class="type">unsigned</span> y)</span> </span>&#123;</span><br><span class="line">  BlcLen[x] = L;</span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="function"><span class="type">unsigned</span> <span class="title">Mid</span><span class="params">((L + R) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="built_in">Build</span>(L, Mid, x, y &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Build</span>(Mid + <span class="number">1</span>, R, x + (y &gt;&gt; <span class="number">1</span>), y &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> C, D, t;</span><br><span class="line">pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; List[<span class="number">400005</span>];</span><br><span class="line">pair&lt;<span class="type">unsigned</span> <span class="type">short</span>, <span class="type">unsigned</span> <span class="type">short</span>&gt; Bel[<span class="number">400005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Word</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; <span class="title">RWT</span><span class="params">(Comp* W)</span> </span>&#123;</span><br><span class="line">    Comp Rt;</span><br><span class="line">    Rt = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">      <span class="keyword">if</span> ((Val[i &gt;&gt; <span class="number">6</span>] &gt;&gt; (i &amp; <span class="number">63</span>)) &amp; <span class="number">1</span>) Rt += W[i];</span><br><span class="line">    <span class="keyword">return</span> &#123;Rt.<span class="built_in">Angle</span>(), Rt.<span class="built_in">Model</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Wd[<span class="number">400005</span>], Q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Plane</span> &#123;</span><br><span class="line">  Comp Ang[<span class="number">256</span>];</span><br><span class="line">  <span class="type">double</span> ALi[<span class="number">512</span>], BLi[<span class="number">512</span>];</span><br><span class="line">  vector&lt;<span class="type">unsigned</span>&gt; Table[<span class="number">512</span>][<span class="number">512</span>];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> TmpA;</span><br><span class="line">    pair&lt;<span class="type">double</span>, <span class="type">unsigned</span>&gt; TmpB[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">      TmpA = <span class="built_in">RandomAng</span>(), Ang[i] = &#123;<span class="built_in">cos</span>(TmpA), <span class="built_in">sin</span>(TmpA)&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) List[i] = Wd[i].<span class="built_in">RWT</span>(Ang);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) TmpB[i] = &#123;List[i].first, i&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(TmpB + <span class="number">1</span>, TmpB + n + <span class="number">1</span>), ALi[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>), <span class="built_in">j</span>(<span class="number">0</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= BlcLen[j + <span class="number">1</span>]) ALi[++j] = TmpB[i].first;</span><br><span class="line">      Bel[TmpB[i].second].first = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) TmpB[i] = &#123;List[i].second, i&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(TmpB + <span class="number">1</span>, TmpB + n + <span class="number">1</span>), BLi[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>), <span class="built_in">j</span>(<span class="number">0</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= BlcLen[j + <span class="number">1</span>]) BLi[++j] = TmpB[i].first;</span><br><span class="line">      Bel[TmpB[i].second].second = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i)</span><br><span class="line">      Table[Bel[i].first][Bel[i].second].<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">Find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; <span class="title">Fd</span><span class="params">(Q.RWT(Ang))</span></span>;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">Mid1</span><span class="params">(lower_bound(ALi, ALi + Blc, Fd.first) - ALi)</span></span>;</span><br><span class="line">    <span class="type">unsigned</span> L2, <span class="built_in">Mid2</span>(<span class="built_in">lower_bound</span>(BLi, BLi + Blc, Fd.first) - BLi), R2;</span><br><span class="line">    Mid1 = <span class="built_in">min</span>(Blc - <span class="number">1</span>, Mid1), Mid2 = <span class="built_in">min</span>(Blc - <span class="number">1</span>, Mid2);</span><br><span class="line">    L2 = ((Mid2 &gt;= Side) ? (Mid2 - Side) : <span class="number">0</span>),</span><br><span class="line">    R2 = ((Mid2 + Side &lt; Blc) ? (Mid2 + Side) : Blc - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">k</span>(<span class="number">0</span>), <span class="built_in">K</span>(Mid1); k &lt;= Side;</span><br><span class="line">         ++k, K = ((K == Blc - <span class="number">1</span>) ? <span class="number">0</span> : (K + <span class="number">1</span>)))</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(L2); j &lt;= R2; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : Table[k][j])</span><br><span class="line">          <span class="keyword">if</span> (Q.<span class="built_in">Diff</span>(Wd[i]) &lt;= C) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">k</span>(<span class="number">1</span>), <span class="built_in">K</span>(Mid1 - <span class="number">1</span>); k &lt;= Side; ++k, --K) &#123;</span><br><span class="line">      K = ((K &gt; <span class="number">0x3f3f3f3f</span>) ? (Blc - <span class="number">1</span>) : K);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(L2); j &lt;= R2; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : Table[k][j])</span><br><span class="line">          <span class="keyword">if</span> (Q.<span class="built_in">Diff</span>(Wd[i]) &lt;= C) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; P[Num];</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">Cnt</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">Tmp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">65536</span>; ++i) Pp[i] = Pp[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">16</span>; ++i) Hex[HexList[i]] = i;</span><br><span class="line">  n = <span class="built_in">RD</span>(), m = <span class="built_in">RD</span>(), A = <span class="built_in">RDll</span>(), B = <span class="built_in">RDll</span>();</span><br><span class="line">  <span class="keyword">while</span> ((Blc * Blc) &lt;= n) Blc &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  Blc &gt;&gt;= <span class="number">1</span>, <span class="built_in">Build</span>(<span class="number">1</span>, n, <span class="number">0</span>, Blc);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt; <span class="number">256</span>; ++j)</span><br><span class="line">      a[j] = (<span class="built_in">myRand</span>() &amp; ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">32</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">255</span>); ~j; --j)</span><br><span class="line">      Wd[i].Val[j &gt;&gt; <span class="number">6</span>] &lt;&lt;= <span class="number">1</span>, Wd[i].Val[j &gt;&gt; <span class="number">6</span>] |= a[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; Num; ++i) P[i].<span class="built_in">Init</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= m; ++i) &#123;</span><br><span class="line">    Q.<span class="built_in">Rd</span>(), Flg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt; Num; ++j)</span><br><span class="line">      <span class="keyword">if</span> (P[j].<span class="built_in">Find</span>()) &#123;</span><br><span class="line">        Flg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, Flg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Wild_Donkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然稍稍调参仍然只可以得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 分, 但是和前面的做法通过的测试点可以互补得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>24</mn></mrow><annotation encoding="application/x-tex">24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span> 分.</p>
<h2 id="常数优化-升维与降维"><a class="markdownIt-Anchor" href="#常数优化-升维与降维"></a> 常数优化: 升维与降维</h2>
<p>我们发现随机游走是没有任何意义的, 它只是为了使得相差不大的两个单词在平面上距离不远, 那么我们有两个改良方向: 升维和降维.</p>
<p>如果我们升维到三维, 那么就相当于把可能存在点的范围变成半径为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>256</mn></mrow><annotation encoding="application/x-tex">256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span></span> 的一个球体, 而我们的搜寻范围是一个半径为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 的球体. 我们把球体内每一个坐标定义一个函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>, 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 是一个三维向量, 表示位置 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 出现一个点的可能性相对值. 因为字典是随机给出的, 所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 空间朝向是不影响 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 的值的. 因此定义实数函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>, 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>X</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">|X| = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span> 的值. 理论上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f&#x27;(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span> 应当是根号函数复合一个正态分布函数, 但是因为询问不是随机给出的, 所以我们不能通过这个函数来分析.</p>
<p>但是仅通过体积来看, 如果存在目标单词, 它确定的范围体积是总体积的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0.0201165676116943359375</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">0.0201165676116943359375\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">2</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">6</span><span class="mord">5</span><span class="mord">6</span><span class="mord">7</span><span class="mord">6</span><span class="mord">1</span><span class="mord">1</span><span class="mord">6</span><span class="mord">9</span><span class="mord">4</span><span class="mord">3</span><span class="mord">3</span><span class="mord">5</span><span class="mord">9</span><span class="mord">3</span><span class="mord">7</span><span class="mord">5</span><span class="mord">%</span></span></span></span>, 比二维的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0.3</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">0.3\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mord">%</span></span></span></span> 小得多. 这里确定的范围没有删除在总体积外的部分, 不过这部分体积对结论影响不大, 因此忽略不计. 又因为点的总数不变, 所以需要验证的点就少了. 理论上我们用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 维的随机游走变换需要验证的体积占总体积的比例是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mfrac><mn>15</mn><mn>256</mn></mfrac><msup><mo stretchy="false">)</mo><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">(\frac {15}{256})^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.194108em;vertical-align:-0.345em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">5</span><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>这么说升维确实可以得到很可观的收益, 不过现在没有有效的查询临近点的算法. 因此还是要进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 的预处理. 剪枝是把点按照第一维存到桶里, 每次只查询可能的第一维. 虽然优化了常数, 并且对绝大部分单词省去了对比两个串的过程, 但是复杂度相比暴力也没有变化. 所以这方面的前途也不大, 不过因为是基于 RWT 的首个确定性算法, 所以还是可以说一说的.</p>
<p>这里有一个实现上的细节, 因为三维的空间方向是不能用一个实数确定的, 所以我们采用随机任意一个三维向量, 然后通过拉伸变成一个随机单位向量.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> HexList[<span class="number">17</span>] = <span class="string">&quot;084C2A6E195D3B7F&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> A, B;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">Blc</span><span class="params">(<span class="number">1</span>)</span>, BlcLen[512]</span>;</span><br><span class="line"><span class="type">unsigned</span> C, D, t;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">Debug</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> Pp[<span class="number">65536</span>], Hex[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">RandomDouble</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">double</span>(<span class="built_in">myRand</span>() % <span class="number">1048576</span>) - <span class="number">524288</span>; &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">  <span class="type">double</span> Val[<span class="number">3</span>];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Model</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Rt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">3</span>; ++i) Rt += <span class="built_in">Sqr</span>(Rt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(Rt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">3</span>; ++i) Val[i] = <span class="built_in">RandomDouble</span>();</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Rt</span><span class="params">(Model())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">3</span>; ++i) Val[i] /= Rt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span>+=(<span class="type">const</span> Vec&amp; x) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">3</span>; ++i) Val[i] += x.Val[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> <span class="title">Dist</span><span class="params">(<span class="type">const</span> Vec&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(Val[<span class="number">1</span>] - x.Val[<span class="number">1</span>]) &gt; C) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(Val[<span class="number">2</span>] - x.Val[<span class="number">2</span>]) &gt; C) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Ang[<span class="number">256</span>];</span><br><span class="line"><span class="type">char</span> a[<span class="number">256</span>], <span class="built_in">Flg</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">unsigned</span> n, m, N;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Word</span> &#123;</span><br><span class="line">  Vec Pos;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> Val[<span class="number">4</span>];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">RWT</span><span class="params">(Vec* W)</span> </span>&#123;</span><br><span class="line">    Pos = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">      <span class="keyword">if</span> ((Val[i &gt;&gt; <span class="number">6</span>] &gt;&gt; (i &amp; <span class="number">63</span>)) &amp; <span class="number">1</span>) Pos += W[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Wd[<span class="number">400005</span>], Q;</span><br><span class="line">vector&lt;<span class="type">unsigned</span>&gt; List[<span class="number">512</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">Find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Q.<span class="built_in">RWT</span>(Ang);</span><br><span class="line">  <span class="function"><span class="type">unsigned</span> <span class="title">L</span><span class="params">(<span class="number">256</span> + (<span class="type">unsigned</span>)Q.Pos.Val[<span class="number">0</span>])</span>, <span class="title">R</span><span class="params">(L + C)</span></span>;</span><br><span class="line">  L = ((L &gt;= C) ? (L - C) : <span class="number">0</span>), R = ((R &lt; <span class="number">512</span>) ? R : <span class="number">511</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(L); j &lt;= R; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : List[j])</span><br><span class="line">      <span class="keyword">if</span> (Q.Pos.<span class="built_in">Dist</span>(Wd[i].Pos) &amp;&amp; (Q.<span class="built_in">Diff</span>(Wd[i]) &lt;= C)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">65536</span>; ++i) Pp[i] = Pp[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">16</span>; ++i) Hex[HexList[i]] = i;</span><br><span class="line">  N = n = <span class="built_in">RD</span>(), N += ((m = <span class="built_in">RD</span>()) &lt;&lt; <span class="number">1</span>), A = <span class="built_in">RDll</span>(), B = <span class="built_in">RDll</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt; <span class="number">256</span>; ++j)</span><br><span class="line">      a[j] = (<span class="built_in">myRand</span>() &amp; ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">32</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">255</span>); ~j; --j)</span><br><span class="line">      Wd[i].Val[j &gt;&gt; <span class="number">6</span>] &lt;&lt;= <span class="number">1</span>, Wd[i].Val[j &gt;&gt; <span class="number">6</span>] |= a[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">256</span>; ++i) Ang[i].<span class="built_in">Random</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i)</span><br><span class="line">    Wd[i].<span class="built_in">RWT</span>(Ang), List[<span class="number">256</span> + (<span class="type">unsigned</span>)Wd[i].Pos.Val[<span class="number">0</span>]].<span class="built_in">push_back</span>(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= m; ++i) &#123;</span><br><span class="line">    Q.<span class="built_in">Rd</span>(), Flg = <span class="number">0</span>;</span><br><span class="line">    Flg = <span class="built_in">Find</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, Flg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Wild_Donkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这份代码在原来的基础上又多 AC 了两个点. 但是发现这样的本质也不过是扫描了三维空间中的第一维坐标落在某个区间内的切片, 所以我们不妨把这些繁杂的外衣褪去, 向另一个方向发展: 降维.</p>
<p>如果把这个问题变成一维, 就会变得好处理多了. 只是复杂度仍然是纯暴力的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 除以一个常数, 优点是代码简单.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> HexList[<span class="number">17</span>] = <span class="string">&quot;084C2A6E195D3B7F&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> A, B;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">Blc</span><span class="params">(<span class="number">1</span>)</span>, BlcLen[512]</span>;</span><br><span class="line"><span class="type">unsigned</span> C, D, t;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">Debug</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> Pp[<span class="number">65536</span>], Hex[<span class="number">256</span>];</span><br><span class="line"><span class="type">char</span> a[<span class="number">256</span>], Ang[<span class="number">256</span>], <span class="built_in">Flg</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">unsigned</span> n, m, N;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Word</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> Val[<span class="number">4</span>];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="title">RWT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">Rt</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">      <span class="keyword">if</span> ((Val[i &gt;&gt; <span class="number">6</span>] &gt;&gt; (i &amp; <span class="number">63</span>)) &amp; <span class="number">1</span>) Rt = (Ang[i] ? (Rt + <span class="number">1</span>) : (Rt - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> Rt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Wd[<span class="number">400005</span>], Q;</span><br><span class="line">vector&lt;<span class="type">unsigned</span>&gt; List[<span class="number">513</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">Find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="type">unsigned</span> <span class="title">L</span><span class="params">(Q.RWT())</span>, <span class="title">R</span><span class="params">(L + C)</span></span>;</span><br><span class="line">  L = ((L &gt;= C) ? (L - C) : <span class="number">0</span>), R = ((R &lt; <span class="number">513</span>) ? R : <span class="number">512</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(L); j &lt;= R; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : List[j])</span><br><span class="line">      <span class="keyword">if</span> (Q.<span class="built_in">Diff</span>(Wd[i]) &lt;= C) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">65536</span>; ++i) Pp[i] = Pp[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">16</span>; ++i) Hex[HexList[i]] = i;</span><br><span class="line">  N = n = <span class="built_in">RD</span>(), N += ((m = <span class="built_in">RD</span>()) &lt;&lt; <span class="number">1</span>), A = <span class="built_in">RDll</span>(), B = <span class="built_in">RDll</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt; <span class="number">256</span>; ++j)</span><br><span class="line">      a[j] = (<span class="built_in">myRand</span>() &amp; ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">32</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">255</span>); ~j; --j)</span><br><span class="line">      Wd[i].Val[j &gt;&gt; <span class="number">6</span>] &lt;&lt;= <span class="number">1</span>, Wd[i].Val[j &gt;&gt; <span class="number">6</span>] |= a[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt; <span class="number">256</span>; ++j)</span><br><span class="line">    Ang[j] = (<span class="built_in">myRand</span>() &amp; ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">32</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) List[Wd[i].<span class="built_in">RWT</span>()].<span class="built_in">push_back</span>(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= m; ++i) &#123;</span><br><span class="line">    Q.<span class="built_in">Rd</span>(), Flg = <span class="number">0</span>, Flg = <span class="built_in">Find</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, Flg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Wild_Donkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得分情况和三维是一样的, 不过省去这些东西之后要比三维快.</p>
<h2 id="和本篇没有太大关系的正解"><a class="markdownIt-Anchor" href="#和本篇没有太大关系的正解"></a> 和本篇没有太大关系的正解</h2>
<p>因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 这个数字比较特殊, 恰好是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">16 - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>.</p>
<p>我们考虑把整个单词分成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 段长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 的二进制串. 如果两个单词相差 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 位以内, 发现根据抽屉原理, 至少有一段是两个单词相同的. 所以可以枚举这个相同的段. 我们发现不同的长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 的二进制串有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>65536</mn></mrow><annotation encoding="application/x-tex">65536</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span></span></span></span> 个, 字典是随即给出的, 所以如果我们指定一个段是某个特定的二进制串, 那么字典里符合条件的单词期望有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6.103515625</mn></mrow><annotation encoding="application/x-tex">6.103515625</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">.</span><span class="mord">1</span><span class="mord">0</span><span class="mord">3</span><span class="mord">5</span><span class="mord">1</span><span class="mord">5</span><span class="mord">6</span><span class="mord">2</span><span class="mord">5</span></span></span></span> 个. 所以对于所有段, 总的判断次数期望是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>97.65625</mn></mrow><annotation encoding="application/x-tex">97.65625</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">7</span><span class="mord">.</span><span class="mord">6</span><span class="mord">5</span><span class="mord">6</span><span class="mord">2</span><span class="mord">5</span></span></span></span> 个, 每次判断需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 的常数, 因此单词询问的常数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1562.5</mn></mrow><annotation encoding="application/x-tex">1562.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">6</span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span></span>. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>≤</mo><mn>1.2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">m \leq 1.2 \times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>, 所以询问的运行时间大约是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1.875</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">1.875 \times 10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">8</span><span class="mord">7</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>, 可以通过此题.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> HexList[<span class="number">17</span>] = <span class="string">&quot;084C2A6E195D3B7F&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> A, B;</span><br><span class="line"><span class="type">unsigned</span> C, D, t;</span><br><span class="line"><span class="type">char</span> Pp[<span class="number">65536</span>], Hex[<span class="number">256</span>], a[<span class="number">256</span>], <span class="built_in">Flg</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">unsigned</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Word</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> Val[<span class="number">16</span>];</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a), C = <span class="built_in">RD</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">63</span>); ~i; --i) Val[i &gt;&gt; <span class="number">2</span>] &lt;&lt;= <span class="number">4</span>, Val[i &gt;&gt; <span class="number">2</span>] |= Hex[a[i]];</span><br><span class="line">    <span class="keyword">if</span> (Flg)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">16</span>; ++i) Val[i] ^= <span class="number">0xFFFF</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="title">Diff</span><span class="params">(<span class="type">const</span> Word&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">Rt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">16</span>; ++i) Rt += Pp[Val[i] ^ x.Val[i]];</span><br><span class="line">    <span class="keyword">return</span> Rt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Wd[<span class="number">400005</span>], Q;</span><br><span class="line">vector&lt;<span class="type">unsigned</span>&gt; List[<span class="number">16</span>][<span class="number">65536</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">Find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt;= C; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : List[j][Q.Val[j]])</span><br><span class="line">      <span class="keyword">if</span> (Q.<span class="built_in">Diff</span>(Wd[i]) &lt;= C) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">65536</span>; ++i) Pp[i] = Pp[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">0</span>); i &lt; <span class="number">16</span>; ++i) Hex[HexList[i]] = i;</span><br><span class="line">  n = <span class="built_in">RD</span>(), m = <span class="built_in">RD</span>(), A = <span class="built_in">RDll</span>(), B = <span class="built_in">RDll</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt; <span class="number">256</span>; ++j)</span><br><span class="line">      a[j] = (<span class="built_in">myRand</span>() &amp; ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">32</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">255</span>); ~j; --j)</span><br><span class="line">      Wd[i].Val[j &gt;&gt; <span class="number">4</span>] &lt;&lt;= <span class="number">1</span>, Wd[i].Val[j &gt;&gt; <span class="number">4</span>] |= a[j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">j</span>(<span class="number">0</span>); j &lt; <span class="number">16</span>; ++j) List[j][Wd[i].Val[j]].<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="built_in">i</span>(<span class="number">1</span>); i &lt;= m; ++i) Q.<span class="built_in">Rd</span>(), <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, Flg = <span class="built_in">Find</span>());</span><br><span class="line">  <span class="keyword">return</span> Wild_Donkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个正解是我本题提交的代码中最短的, 真是乐死了.</p>
<h2 id="加强"><a class="markdownIt-Anchor" href="#加强"></a> 加强</h2>
<p>因为本题本来就不是给 RWT 出的, 所以它的表现没有那么出色, 不过如果我们加强一下此题, 就可以得到一个 RWT 的模板.</p>
<p>发现本题的强制在线没有完全强制, 假设有一个复杂度正确的离线做法, 我们完全可以把询问串和询问串的反串都存下来, 离线询问结束之后, 从头开始把询问扫一遍, 上一次答案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 就输出原串答案, 否则输出反串答案. 因此我们索性直接去掉强制在线.</p>
<p>因为 RWT 的核心是判断 “相似”, 但是原题更多的利用的是部分 “相同” 的性质, 所以我们把单词的定义改为整数序列. 当然仍然利用题目字典随机的性质, 只不过每一位是从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000000000</mn></mrow><annotation encoding="application/x-tex">1000000000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 均匀随机, 相似则定义为每一位上两个串差的绝对值的总和小于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10000</mn></mrow><annotation encoding="application/x-tex">10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>, 发现这样抽屉原理就不攻自破了, 因为可以构造出两个相似的串, 使它们每一位都不同.</p>
<p>但是因为我们的方法时间瓶颈在于找距离小的点, 而判断两个点距离的常数和计算两个串是否相似的常数相似. 我们减少了后者的调用次数, 所以为了体现算法的长处, 需要增加后者的优势, 这一点上我们把每个单词变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>512</mn></mrow><annotation encoding="application/x-tex">512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span></span></span></span> 的长度. 一下子判断距离的常数就比后者小得多了. 为了匹配 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">nm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span></span></span></span> 的复杂度, 我们使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 都在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10000</mn></mrow><annotation encoding="application/x-tex">10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 以内. 但即使是这样, 原做法也无法通过了.</p>

                        </div>

                        <!-- Post Comments -->
                        
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'Wild-Donkey'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://wild-donkey.github.io/Engineering/Random_Wandering_Transform/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://wild-donkey.github.io/Engineering/Random_Wandering_Transform/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//Wild-Donkey.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


                      </div>
                      <!-- Copyright 版权 start -->
                              <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
                </div>
              </body>


              
 	
</html>
