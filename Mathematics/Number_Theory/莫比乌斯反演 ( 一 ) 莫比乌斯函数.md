# 莫比乌斯反演 ( 一 ): 莫比乌斯函数

这是一个积性函数, 目前没有具体意义, 是一个工具函数, 用μ(x)表示.

定义域:正整数(N)

### 定义:
$$
μ(x)=\left\{ \begin{aligned} 1\ (x=1) \\ 0\ ((x>1)\ \&\&\ (x有完全平方因数(除1以外))) \\ (-1)^{x的质因数数量} \ (其他情况) \end{aligned} \right.
$$

### 性质:

μ(xy)=μ(x)μ(y)		积性函数特性

μ(1)=1					可以由上一个性质推出

### 求莫比乌斯函数:

**欧拉筛: 积性函数通法**

只要将边界修改一下, 就能线性求出任何定义域为N的积性函数.

```c++
bool prm[n];//存一个数是否是质数
int pri[n];//存质数
int Mu[n];//μ函数
inline void Prime(LL n){
	Mu[1]=1;//μ(1)为1
	for(register int i=2;i<=n;i++){//从2开始筛
		if(!prm[i]) {//筛完后落下的就是质数
            pri[ ++pri[ 0 ] ]=i;//将质数记录在pri里, pri[0]存当前质数数量属于计数器
            Mu[i]=-1;//质数只有一个质因数, (-1)^1=-1
        }
		for(register int j = 1; ( j <= pri [ 0 ] ) && ( i * pri [ j ] <= n ); j++) {//当前数和已知所有质数都相乘, 则积是合数.
			prm[ i * pri[ j ] ] = 1;//筛掉i * pri[j]
			if( i % pri[ j ] == 0 ) {
                break;//只要整除, 那么(i*pri[j])一定有完全平方因数(pri[j]^2)(i里一个,pri[j]本身一个),这是μ(i*pri[j])=0
            }
			Mu[ i * pri[ j ] ] = -(Mu[ i ]);//不整除, (i*pri[j])在i的基础上多了一个质因数(pri[j])
		}
	}
}
```

### 关于register前缀:

常在循环语句中使用, 优化多次重复调用同一个变量. 将之前多次在内存中调用转化为直接在cache里面调用, 节省时间.