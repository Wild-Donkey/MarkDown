[TOC]

# 

计算模型: 顺序模型(图灵机, 有限状态机, 下推自动机), 函数式模型(递归函数, 元胞自动机), 同步模型(演员模型) 有限状态机可计算的函数, 图灵机也可计算, 反之不然.

(计算)函数问题.

## 决策问题

(分类)决策问题: 输入是否是 A, 被编码为字符串集合

正则语言 ⊆ 上下文无关语言 ⊆ 图灵可判定语言 ⊆ 图灵可识别语言 

## 不可计算

丢番图方程: 不存在算法判定是否有整数解.

谓词公式: (一元谓词公式可判定/个体域有穷可判定/特殊限制的谓词公式可判定) 一般的谓词公式不可判定.

停机问题: 判定程序在给定输入下是否停机, 不可判定.

王氏铺砖问题: 无法判定给定的瓷砖集合能否铺满任意整数边长正方形.

## 复杂度相关

# 语言

字符集: 有限个符号的集合

字符串: 字符序列

字符串的连接 $wv$, 反转 $w^R$, 空串 $\epsilon$, $\lambda$, 指数 $w^n = www...w$, 任意串 $\Sigma^* = \Sigma^+ + \{\epsilon\}$.

语言: 字符串集合, 即 $L \subseteq \Sigma^*$. 空语言 $\emptyset$, 仅有空串的语言 $\{\epsilon\}$.

语言的交, 并, 补, 差即为集合的交, 并, 补, 差. 语言的反转是所有字符串反转后的集合. 语言连接是所有字符串连接后的集合(笛卡尔积). 语言的幂是语言中字符串的幂的集合 (连接 $n$ 次). 也有 $^*$ 和 $^+$ 闭包.

## 正则语言

存在四种标准表示: DFA, NFA, 正则表达式, 正则文法.

正则语言对交, 并, 补, 连接, 星号, 反转闭合.

证明时将正则语言的自动机转化成有且仅有一个接受状态的 NFA. 并就是用一个源点连两个 $\epsilon$ 到两个 NFA 的起点. 连接就是把第一个 NFA 的接受状态连 $\epsilon$ 到第二个 NFA 的起点, 并把第一个 NFA 的接受状态改为非接受状态. 星号就是把接受状态连 $\epsilon$ 到起点, 并且新建一个源点作为新的起点和接受状态, 连 $\epsilon$ 到原起点. 反转就是把所有边反向, 并把原起点改为接受状态, 原接受状态改为起点. 补就是先把 NFA 转成 DFA, 然后把接受状态和非接受状态互换. 交比较复杂, 需要用到德摩根律, 两个语言的补的并的补就是交, 或者将两个 NFA 的状态求笛卡尔积, 得到并的状态转移, 两个状态都是接受状态才接受.

正则表达式: $+$ 是并, $\cdot$ 是连接, $^*$ 是闭包, $\epsilon$ 是空串, $\emptyset$ 是空语言. 正则表达式等价当且仅当它们的正则语言相等. 考虑原语 (单字符, 空串, 空语言) 的语言, 将 $+$, $\cdot$, $^*$ 变成语言的并, 连接, 闭包, 即可对任意正则表达式构造对应的正则语言. 将正则语言的自动机转成有且仅有一个接受状态的 NFA, 然后用正则表达式代替转移边 ($+$ 代替逗号), 然后缩点 (环路就是星号, 路径就是连接, 多条边就是并), 最后只剩两个点, q0 和 qf, 各自有表达式分别是 r1, r4 的自环, 正向边 r2, 反向边 r3, 则最终表达式为 $r1^*r2(r4+r3r1^*r2)^*$.

## 上下文无关语言

是正则语言的超集. 可以由上下文无关文法或下推自动机描述.

回文, 合法的括号序列都是上下文无关语言.

证明上下文无关文法的语言可以被 PDA 识别, 构造 PDA, 使得推理过程的瞬时描述中的剩余输入和栈分别对应文法最左推导过程中的的终结符串和变量串. 其中 PDA 只需三个状态, $q_0$, $q_1$, $q_2$, 其中 $q_0$ 是起始状态, $q_2$ 是接受状态. $q_0$ 到 $q_1$ 压入起始变量, $q_1$ 在栈空之后转移到 $q_2$. 而 $q_1$ 的自环非常丰富, 是文法推导的模拟. 对于每个产生式 $A \rightarrow w$, 有自环 $\epsilon, A \to w$, 意为将变量 $A$ 替换为句子 $w$. 对于每个终结符 $a$, 有自环 $a, a \to \epsilon$, 意为读到了对应的字符, 期待的字符变成推导树上这个点右边的一个叶子. 这样只有将所有的变量都推导成终结符, 并且读入的字符串和推导出的字符串相等时, 才能到达接受状态. 一个串也只有符合文法生成时才能将栈从初始变量 $S$ 推理到空.

证明 PDA 识别的语言可以被上下文无关文法生成. 首先处理 PDA, 将它所有接受状态连空边到汇点, 将汇点设为唯一接受状态 $q_{f_1}$. 然后在原来 PDA 的初始状态 $q_0$ 前, 加两个状态, 分别是 $q_{-1}$, $q_{-2}$, 假设原栈底是 $\$$, 则新栈底设为 $\#$, 然后将初始状态设为 $q_{-2}$, 从 $q_{-2}$ 到 $q_{-1}$ 压入 $@$, 从 $q_{-1}$ 到 $q_{0}$ 压入 $\$$, 保证原来的 PDA 可以正常运行. 然后再在 $q_{f_1}$ 后面加两个状态 $q_{f_2}$, $q_{f_3}$, 从 $q_{f_1}$ 到 $q_{f_2}$ 连空边, 从 $q_{f_2}$ 连弹栈自环, 弹出除了 $@$ 和 $\#$ 外所有字符, 最后向 $q_f$ 连弹出 $@$ 的边, 这样保证了接受时栈里只有 $\#$. 然后将既弹栈又进栈的转移通过增加中间状态变成只弹栈和只入栈两条边, 将不弹不入的转移拆成压入再弹出任意字符的两条边. 这样得到了规范化的 PDA. 接下来构造文法. 首先根据状态矩阵设置变量, 即每个状态有序对都有一个变量. 我们可以把变量 $A_{p, q}$ 当作是从状态 $p$ 到状态 $q$ 的一条路径, 然后令起始变量为新起始状态和新接受状态的二元组的变量. 初始变量表示从起始走向接受的路径生成的所有可能的串. 每次派生都可能把路径拆分, 或是走路径上的某些转移. 到了最后路径是自环的时候, 也就结束了. 因此对于主对角线上的变量, 设置一个空串的导出式. 对于每个状态有序三元组, 令 $A_{p,q}$ 导出到 $A_{p, r}A_{r, q}$, 表示将一个路径通过中间点 $r$ 拆成两条. 每一对这样的转移, $\delta(p, a, \epsilon) = {(r, t)}$, $\delta(s, a, t) = {(q, \epsilon)}$, 加入产生式 $A_{p, q} \to aA_{r, s}b$, 表示忽略压栈弹栈中间的所有操作, 只关注外层两步转移, 用对应字符替换转移. 只要存在 PDA 能识别的串, 就存在一条从起始状态到接受状态的路径, 该路径可以拆分成若干段, 这个过程可以用文法的推导来模拟, 最终生成该串. 反之亦然.

上下文无关语言在并, 连接, 闭包上封闭. 并只需在对应的文法前加一个新起始变量, 它可以导出两个文法的起始变量. 连接只需新建一个起始变量, 它导出第一个文法的起始变量加上第二个文法的起始变量. 闭包只需新建一个起始变量 $S_1 \to SS_1|\lambda$.

上下文无关语言在交, 补上不封闭. $\{a^nb^mc^m\} \cap \{a^nb^nc^m\} = \{a^nb^nc^n\}$. 两个语言都是上下文无关语言, 但是交集不是上下文无关语言. 补也显然, 如果上下文无关语言在补上封闭, 则根据德摩根律, 在交上也封闭.

上下文无关语言交正则语言是上下文无关语言. 仍然像前面合并 NFA 一样, 将 PDA 的状态和 NFA 的状态求笛卡尔积, 构造新的 PDA 即可, 因为栈操作只有 PDA 有, 因此新的 PDA 的栈操作以原 PDA 的操作为准.

## 泵引理

基于鸽巢原理, 证明某语言不是正则语言的常用方法.

对于一个无限正则语言 L, 构造一个 DFA, 有 p 个状态. 取一个串 w, 满足 $|w| \geq p$, 得到它在 DFA 上的路径. 路径上应当有 $|w| + 1 > p$ 个 状态, 由于鸽巢原理, 有一个或以上的状态出现一次以上.

将 $w$ 分为三段 $xyz$, 其中 $xy$ 到达的状态是首个重复状态的第二次出现, $x$ 到达的是首个重复状态的第一次出现, $z$ 是剩余部分. 显然 $|y| \geq 1$, 而且 $xy$ 到达的状态中有 $|xy|$ 个独立状态, 因此 $|xy| \leq p$. 根据 DFA 的定义, $xy^iz \in L,  i \in N$. 

泵引理: 任意无限正则语言 L, 存在一个整数 p, 对任意字符串 $w \in L$, 如果 $|w| \geq p$, 则存在 $w = xyz$, $|y| \geq 1$, $|xy| \leq p$, 满足: $xy^iz \in L,  i \in N$.

有限语言一定是正则语言. 非正则语言一定无限. 证明某语言非正则时, 假设它是正则的, 如果泵引理不成立, 则矛盾, 该语言非正则.

但是, 泵引理只是无限正则语言的必要条件, 不是充分条件. 

上下文无关语言也有泵引理. 对任意无限上下文无关语言 L, 存在足够长的串 $w \in L$, 在被 PDA 接受时经过至少一个状态多于一次. 在原来的语言中移除空串, 然后在新的文法中移除单位产生式和空串产生式. 假设有 $r$ 个变量, 每个产生式的句子不超过 $t$. 则取语言中长度大于 $t^r$ 的串 $w$, 在推导树中至少有一个变量在某条从根到叶子的路径上出现两次. 这是因为 $w$ 至少有 $r + 2$ 层节点 ($r + 1$ 层最多生成 $t^r$ 个终结符). 存在一个从根到叶子的 $r + 2$ 个节点的路径, 去掉叶子还有 $r + 1$ 个节点, 根据鸽巢原理, 至少有一个变量出现大于一次.

假设最深的重复的变量 $H$, 在同一根到叶子的路径上出现了两次: $H_1$ 和后代 $H_2$, 且 $H_1$ 到叶子路径中不存在其他变量重复 (如果存在, 则取子树中的变量). 记 $H_1$ 的子树叶子的终结符串是 $vxy$, $H_2$ 的子树叶子终结符串 $x$, 整个串 $w = uvxyz$. 其中 $uvxyz$ 由 $S$ 派生, $vxy$ 和 $x$ 都是 $H$ 派生. 那么显然 $uv^ixy^iz, i \in N$ 都属于 L.

因为删去了单位产生式, 所以 $|v| + |y| \geq 1$; 又因为不存在 $H_1$ 到叶子的路径中其他变量重复, 所以 $H_1$ 到叶子的路径最多有 $r + 2$ 层, 最多 $t^{r + 1}$ 个终结符, 因此 $|vxy| \leq t^{r + 1}$. 因此取 $p = t^{r + 1} > t^r$.

因此无限上下文无关语言的泵引理是: $\exist w \in L, |w| \geq p$, 有分解 $w = uvxyz$, 其中 $|v| + |y| \geq 1$, $|vxy| \leq p$, 满足: $uv^ixy^iz \in L, i \in N$. 满足泵引理是无限上下文无关语言的必要条件, 不是充分条件.

## 图灵接受语言

可以被图灵机接受的语言的集合, 包含了上下文无关语言.

一个语言, 它的枚举器是一个图灵机, 可以一个接一个地生成该语言中的所有字符串. 如果一个集合存在枚举器, 则集合可数.

图灵机是可数的: 二进制串是可数的.

语言是不可数的: 无限可数集合的幂集不可数. 二进制串的集合的幂集不可数. 用二进制编码的无限集合子集的长度无限, 假设这个编码集合是可数的, 将所有串左对齐, 按顺序从上到下排成矩阵, 对角线上的值取反得到新串, 它应当是集合的成员, 但是根据刚才的推理, 它一定不存在于这个矩阵中. 推翻假设, 语言不可数.

每个图灵机都有它接受的语言, 这些语言组成一个可数的可重集, 因此一定存在语言不被任何图灵机接受, 即不可计算语言.

## 可判定语言

是图灵可识别语言的子集, 存在一定能停机的图灵机接受的语言. 一个计算问题是可判定的, 也说这个问题是可计算的.

显然一个可判定语言的补也是可判定的. (对输出取反)

## 不可判定语言

对图灵可接受语言 $L$ 取补集, 如果 $\overline L$ 是图灵不可接受的, 那么根据可判定语言的补集也可判定, $L$ 一定是不可判定的.

使用单个字符的字符集 $\{a\}$. 显然字符串可数, 图灵机可数, 而语言不可数. 将图灵机按从上到下, 字符串从左到右, 构造一个接受矩阵. 使用对角线法则, 将对角线的值作为 $L$, 取反得到一个不可判定语言 $\overline L$.

# 自动机

有限自动机: 无临时内存

下推自动机: 有栈作为临时内存

图灵机: 有无限长的纸带作为临时内存

越灵活的内存可以计算越复杂的问题. 图灵机可以计算目前所有已知的可计算问题.

## FSM

Finite-State Machines, 有限状态机.

有输出的 FSM: $M = (S, I, O, f, g, s_0)$. 有限个状态 $S$, 指定的起始状态 $s_0$, 输入字母表 $I$, 输出字母表 $O$, 和一个转换函数 $f$, 输出函数 $g$, 对每个 (状态, 输入) 指定下一个状态或输出.

无输出的 FSM(FSA): $M = (S, I, f, s_0, F)$. 没有 $O$, $g$, 多了 $S$ 的子集 $F$ 作为接受状态集. 输入字符串被接受当且仅当 FSM 在读完字符串后处于某个接受状态.

都可以用 state table 描述 $f$ 和 $g$, 或者是有向图 state diagram 描述逻辑关系.

## DFA/NFA

DFA 确定性有限自动机: 对每个 (状态, 输入) 有且仅有一个下一个状态. 特殊的 FSA. $M = (Q, \Sigma, \delta, q_0, F)$.

从起始状态开始读入字符串, 按照 $\delta$ 转换状态, 所有字符读完后如果处于接受状态则接受该字符串. 否则拒绝.

$\delta^*$ 是扩展的转换函数, 接受一个状态和一个串, 返回从这个状态开始读入该串后到达的状态. 读入空串 $\epsilon$ 时状态不变.

被 DFA 接受的语言叫做正则语言. DFA 不能识别 $a^nb^n$ 或加法 $1^n+1^m=1^{n + m}$.

NFA 非确定性有限自动机: 一个 (状态, 输入) 可能转换到多个或零个状态的集合, 甚至存在状态直接转移输入 $\epsilon$. 只要存在一条路径能到达接受状态就接受该字符串. 如果无路可走或结束于非接受状态则拒绝. 扫描时存在可达的状态集合, 从集合中每个状态判断下一个字符, 得到新的可达集合.

NFA 的 $\delta$ 同样可扩展.

如果接受的语言相同, 那么两种自动机计算能力等价. NFA 接受正则语言, 且 NFA 和 DFA 等价(可相互转换).

DFA 本身满足 NFA 条件, NFA 可转换为 DFA. 考虑在推理过程中 NFA 的可达状态集合(或者直接列出 Q 的幂集), 因为状态有限, 所以可达状态集合有限, 因此可以把一个集合看作 DFA 的一个状态, 然后构造转移即可. (归纳法证明构造的 DFA 和原 NFA 等价)

## PDA

Pushdown Automata, 下推自动机. 有限状态机加上一个栈作为临时内存, 栈内存在特殊字符 $\$$ 表示栈底. 转移边 $a, b \rightarrow c$, 其中 $a$ 是输入字符, $b$ 是弹出字符, $c$ 是压入字符. PDA 是不确定的. 允许重边和 $\epsilon$ 边.

弹出和压入的也可以是字符串, 可以通过在弹出压入字符的 PDA 中加入中间状态来实现. 书写时串从左到右在栈中是从栈顶到栈底的顺序.

形式化表示 $M(Q, \Sigma, \Gamma, \delta, q_0, z, F)$. 即为有穷状态集 $Q$, 输入字母表 $\Sigma$, 栈字母表 $\Gamma$, 转移函数 $\delta, 起始状态 $q_0$, 栈初始字符 $z$, 接受状态集 $F$. 

转移函数可以通过输入输出描述: $\delta(q_1, a, w_1) = {(q_2, w_2)}$, 意为在状态 $q_1$ 下读入字符 $a$, 弹出栈顶字符串 $w_1$, 压入栈顶字符串 $w_2$, 转移到状态 $q_2$.

瞬时描述 (ID): 三元组 $(q, u, s)$. 状态 $q$, 剩余输入串 $u$, 栈内容 $s$ (栈顶在左). 可以用 $\succ$ 连接瞬时描述来记录过程, 用 $\overset{*}{\succ}$ 省略中间过程.

## DPDA

DPDA 是确定性的 PDA, 它并不等价于 PDA. DPDA 只能识别一部分上下文无关语言, 即确定性上下文无关语言. DPDA 只允许每个 (状态, 输入, 栈顶) 有且仅有一个转移, 或者允许 $\epsilon$ 输入转移但不允许普通输入转移, 不能两者兼有.

所谓确定性, 即对于某个输入, DPDA 的行为是唯一确定的. 这就丧失了 PDA 的非确定性能力, 比如猜测 $vv^R$ 的中点位置的能力.

证明 $\{a^nb^n\} \cup \{a^nb^{2n}\}$ 是不确定性上下文无关语言. 假设存在 DPDA M 能识别该语言, 由于确定性, 在接受 $a^nb^{2n}$ 的过程中, 在扫描完 $a^nb^n$ 之后到达了一个接受状态, 然后扫描下一段 $b^n$ 到达接受状态. 将 M 中的 $b$ 都改成 $c$, 构造出接受 $\{a^nc^n\} \cup \{a^nc^{2n}\}$ 的 DPDA M'. 这时候将 M 中 $a^nb^n$ 的状态向 M' 中 $a^nc^n$ 的状态连空边, 这时候联合 DPDA 就存在了显然的接受 $a^nb^nc^n$ 的路径. 已知 $\{a^nb^nc^n\}$ 不是上下文无关语言, 而新的 DPDA 接受 $\{a^nb^n\} \cup \{a^nb^{2n}\} \cup \{a^nc^n\} \cup \{a^nc^{2n}\} \cup \{a^nb^nc^n\}$, 显然不是上下文无关语言, 发生矛盾, 推翻假设.

## 图灵机

存在一个无限长纸带作为内存. 有一个可以左右移动的读写头. 每步读一个字符, 写一个字符, 向左或右移动一步.

输入串在纸带上, 一开始磁头在输入串的最左端. 剩余位置由空白符号 $\Diamond$ 填充. 每个转移由读入的字符, 写字符, 移动方向组成. 图灵机是确定性的, 并且不要求每个 (状态, 输入) 都有转移. 如果没有转移则停机. 在接受状态停机则接受该字符串, 否则拒绝, 不能有从接受状态出发的转移. 因此无需读完整个输入就可接受. 如果无限运行则拒绝.

转移函数可以这样描述 $\delta(q_1, a) = {(q_2, b, L/R)}$. 图灵机 $M = (Q, \Sigma, \Gamma, \delta, q_0, \Diamond, F)$. 有限状态集 $Q$, 输入字母表 $\Sigma$, 磁带字母表 $\Gamma$, 转移函数 $\delta$, 起始状态 $q_0$, 空白符号 $\Diamond$, 接受状态集 $F$. 瞬时描述是纸带上的字符加上磁头位置和状态, 我们将状态名插入在磁头指向的位置前面.

邱奇-图灵论题: 任何“可计算”的函数都可以被图灵机计算.

算法: 解决某问题的图灵机是这个问题的算法.

其他模型: 单向无限图灵机, 多带图灵机, 多维图灵机, 非确定性图灵机, 含停留操作的图灵机. 它们的计算能力和普通图灵机等价. 证明方式是用一种模型模拟另一种模型.

含停留操作可以通过增加中间状态一左一右来模拟; 多道纸带共享同一个读写头, 可以把纸带字符集变成每道字符集的笛卡尔积来模拟; 单向无限纸带可以通过模拟成单向双道图灵机, 然后再模拟成普通图灵机来实现, 参考点左边是一条带, 参考点右边是另一条带; 多带图灵机用多道图灵机模拟, 每个带对应一条数据带和位置带, 位置带记录读写头位置, 设一个参考点, 每次需要对某个纸带进行访问时, 回到参考点, 移动到位置带为 $1$ 的地方进行修改; 用双道图灵机, 一道存储数据, 一道存储位置, 每次更新当前位置, 计算下一个位置的坐标, 找到下一个坐标; 用二维图灵机模拟非确定性图灵机, 通过第二维可以广度优先地枚举非确定图灵机所有可能的计算路径.

计算能力相同不代表复杂度相同, 普通图灵机模拟多带图灵机时, 复杂度可能升高. 比如判定 $\{a^nb^n\}$ 的单带图灵机需要 $O(n^2)$ 时间, 而 $2$ 带图灵机只需 $O(n)$ 时间.

通用图灵机: 可编程, 可以模拟任意图灵机. 输入是被模拟的图灵机和输入数据. 含有三个纸带: 程序带, 输入带, 状态带. 纸带内容可以用 0 和 1 编码, 输入图灵机构成了一个语言.

# 文法

$G=(V, T, S, P)$, 有变量集合 $V$, 终结符集合 $T$, 起始符号 $S$, 产生式集合 $P$. 产生式形式为: 变量 $\rightarrow$ 句子. 包含终结符和变量的句子是句型, 句型可以派生 $\Rightarrow$ 出句子, 多次派生可以省略中间步骤以 $\xRightarrow{*}$ 表示. 由起始符号派生出的所有终结符串的集合即为文法对应的语言.

一个变量对应多个产生式时, 可用 $|$ 分隔不同句子.

## 线性文法

所有产生式的句子最多有一个变量.

左/右线性文法: 变量在左/右侧.

## 正则文法

生成正则语言的文法. 任意左/右线性文法.

设 G 是右线性文法, 构造 NFA: 每个变量对应一个状态, 起始状态对应起始变量, 另加一个新建的接受状态. 每个产生式, 如果句子是单个变量, 则连接 $\epsilon$ 边; 如果句子不含变量, 则根据终结符数量增加中间状态, 按顺序连接终结符边, 结束于接受状态; 如果句子是终结符加变量, 则先根据终结符数量增加中间状态, 按顺序连接终结符边, 结束于变量对应状态. 这样构造的 NFA 接受的语言和 G 生成的语言相同.

如果 G 是左线性文法, 则构造右线性文法 G', 使得 $L(G) = L(G')^R$. G' 只需将所有产生式的句子反转即可. 然后再将 G' 转成 NFA. 再将 NFA 做反转. 因此所有正则文法的语言都是正则语言.

接下来证明所有正则语言都能用正则文法描述. 先建立语言的 NFA, 然后为每个状态建立一个变量. 起始状态对应起始变量. 每个转移边都是一个产生式, 如果边是字符, 则产生式的句子是该字符加目标状态对应变量; 如果边是 $\epsilon$, 则句子是目标状态对应变量. 最后给每个接受状态对应变量增加一个产生式, 句子是空串 $\epsilon$. 因此所有正则语言都能用正则文法描述.

## 上下文无关文法

生成上下文无关语言.

最左/最右推导: 每次替换最左/最右侧的变量.

推导树: 根节点是起始符号, 每次替换变量, 产生这个变量的子节点, 终结符作为叶节点, 按从左到右的顺序排列, 得到的树就是推导树. 按照从左到右遍历叶子就得到了最后的字符串.

上下文无关文法是有歧义的, 同一个终结符串也可能有两种不同的推导树. 歧义的语言只能由歧义文法生成. 但是有些语言既存在歧义文法也有无歧义文法.

可以通过将非起始变量替换为它的产生式的句子来消除无用产生式和无用变量.

单位产生式: 形如 $A \rightarrow B$ 的产生式, 其中 A, B 是变量. 可以通过将 A 的所有产生式加到 B 上来消除单位产生式.

无用产生式: 不能推出任何终结符串的产生式. 永不结束的变量和不可达变量对应的产生式都是无用产生式. 有用的变量也可能存在无用产生式.

乔姆斯基范式: 每个产生式的句子要么是两个变量, 要么是单个终结符. 为每个终结符建立一个新变量, 并将该变量替换终结符 (只有一个终结符的产生式不用变). 然后将句子长度大于 2 的产生式拆分成多个两个变量的产生式即可. 不含 $\epsilon$ 的上下文无关文法都能转换成乔姆斯基范式. 首先移除可空变量和单位产生式, 然后进行上述转换.

格雷巴赫范式: 每个产生式的句子最前面是一个终结符, 后面跟着零个或多个变量. 比乔姆斯基范式难找.

# P, NP, NP-Hard, NP-Complete

P(Polynomial): 多项式时间可解问题的集合.

NP(Non-deterministic Polynomial): 多项式时间可验证问题的集合.

NPC(NP-Complete): NP 中的最难问题, 多项式时间归约到其他 NPC 问题. (被认为指数时间可解, 一旦某个 NPC 有多项式时间算法, 则 P = NPC)



图同构: $n^{\log n}$.

整数分解: 亚指数时间.

哈密顿路: 尚无多项式时间算法. 

## SAT



## NPC

数独, 扫雷, 俄罗斯方块.

- 集合覆盖
集合的集合 $S$ 的所有元素并成全集 $U$. 判断 $S$ 是否存在 $k$ 大小的子集, 其并等于 $U$.

- 子集和
给定整数集合 $S$ 和整数 $t$, 判断是否存在 $S$ 的子集, 其和为 $t$.

- 划分
给定整数集合 $S$, 判断是否存在 $S$ 的子集 $S_1$, 使得 $S - S_1$ 的和等于 $S_1$ 的和. 其实就是子集和的特例 $t = \frac{\sum S}{2}$.

- 背包
$n$ 个物品, 每个物品有重量 $w_i$ 和价值 $v_i$. 背包容量 $C$, 目标价至 $T$, 是否存在方案选择物品集合, 使得总重量不超过 $C$ 且总价值至少为 $T$.

- 装箱
$n$ 个物品, 每个物品有体积, 每个箱子容量 $B$, 问是否能用 $k$ 个箱子装下所有物品.

- 斯坦纳树

- 图染色

- 独立集

- 支配集

- 最长路

- 旅行商

- 最大割

- 并行机器调度



