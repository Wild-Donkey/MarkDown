[TOC]

# 

计算模型: 顺序模型(图灵机, 有限状态机, 下推自动机), 函数式模型(递归函数, 元胞自动机), 同步模型(演员模型) 有限状态机可计算的函数, 图灵机也可计算, 反之不然.

(计算)函数问题.

## 决策问题

(分类)决策问题: 输入是否是 A, 被编码为字符串集合

正则语言 ⊆ 上下文无关语言 ⊆ 图灵可判定语言 ⊆ 图灵可识别语言 

## 不可计算

丢番图方程: 不存在算法判定是否有整数解.

谓词公式: (一元谓词公式可判定/个体域有穷可判定/特殊限制的谓词公式可判定) 一般的谓词公式不可判定.

停机问题: 判定程序在给定输入下是否停机, 不可判定.

王氏铺砖问题: 无法判定给定的瓷砖集合能否铺满任意整数边长正方形.

## 复杂度相关

# 自动机

有限自动机: 无临时内存

下推自动机: 有栈作为临时内存

图灵机: 有无限长的纸带作为临时内存

越灵活的内存可以计算越复杂的问题. 图灵机可以计算目前所有已知的可计算问题.

# 语言

字符集: 有限个符号的集合

字符串: 字符序列

字符串的连接 $wv$, 反转 $w^R$, 空串 $\epsilon$, $\lambda$, 指数 $w^n = www...w$, 任意串 $\Sigma^* = \Sigma^+ + \{\epsilon\}$.

语言: 字符串集合, 即 $L \subseteq \Sigma^*$. 空语言 $\emptyset$, 仅有空串的语言 $\{\epsilon\}$.

语言的交, 并, 补, 差即为集合的交, 并, 补, 差. 语言的反转是所有字符串反转后的集合. 语言连接是所有字符串连接后的集合(笛卡尔积). 语言的幂是语言中字符串的幂的集合 (连接 $n$ 次). 也有 $^*$ 和 $^+$ 闭包.

# 自动机

## FSM

Finite-State Machines, 有限状态机.

有输出的 FSM: $M = (S, I, O, f, g, s_0)$. 有限个状态 $S$, 指定的起始状态 $s_0$, 输入字母表 $I$, 输出字母表 $O$, 和一个转换函数 $f$, 输出函数 $g$, 对每个 (状态, 输入) 指定下一个状态或输出.

无输出的 FSM(FSA): $M = (S, I, f, s_0, F)$. 没有 $O$, $g$, 多了 $S$ 的子集 $F$ 作为接受状态集. 输入字符串被接受当且仅当 FSM 在读完字符串后处于某个接受状态.

都可以用 state table 描述 $f$ 和 $g$, 或者是有向图 state diagram 描述逻辑关系.

## DFA/NFA

DFA 确定性有限自动机: 对每个 (状态, 输入) 有且仅有一个下一个状态. 特殊的 FSA. $M = (Q, \Sigma, \delta, q_0, F)$.

从起始状态开始读入字符串, 按照 $\delta$ 转换状态, 所有字符读完后如果处于接受状态则接受该字符串. 否则拒绝.

$\delta^*$ 是扩展的转换函数, 接受一个状态和一个串, 返回从这个状态开始读入该串后到达的状态. 读入空串 $\epsilon$ 时状态不变.

被 DFA 接受的语言叫做正则语言. DFA 不能识别 $a^nb^n$ 或加法 $1^n+1^m=1^{n + m}$.

NFA 非确定性有限自动机: 一个 (状态, 输入) 可能转换到多个或零个状态的集合, 甚至存在状态直接转移输入 $\epsilon$. 只要存在一条路径能到达接受状态就接受该字符串. 如果无路可走或结束于非接受状态则拒绝. 扫描时存在可达的状态集合, 从集合中每个状态判断下一个字符, 得到新的可达集合.

NFA 的 $\delta$ 同样可扩展.

如果接受的语言相同, 那么两种自动机计算能力等价. NFA 接受正则语言, 且 NFA 和 DFA 等价(可相互转换).

DFA 本身满足 NFA 条件, NFA 可转换为 DFA. 考虑在推理过程中 NFA 的可达状态集合(或者直接列出 Q 的幂集), 因为状态有限, 所以可达状态集合有限, 因此可以把一个集合看作 DFA 的一个状态, 然后构造转移即可. (归纳法证明构造的 DFA 和原 NFA 等价)

# 语言

## 正则语言

存在四种标准表示: DFA, NFA, 正则表达式, 正则文法.

正则语言对交, 并, 补, 连接, 星号, 反转闭合.

证明时将正则语言的自动机转化成有且仅有一个接受状态的 NFA. 并就是用一个源点连两个 $\epsilon$ 到两个 NFA 的起点. 连接就是把第一个 NFA 的接受状态连 $\epsilon$ 到第二个 NFA 的起点, 并把第一个 NFA 的接受状态改为非接受状态. 星号就是把接受状态连 $\epsilon$ 到起点, 并且新建一个源点作为新的起点和接受状态, 连 $\epsilon$ 到原起点. 反转就是把所有边反向, 并把原起点改为接受状态, 原接受状态改为起点. 补就是先把 NFA 转成 DFA, 然后把接受状态和非接受状态互换. 交比较复杂, 需要用到德摩根律, 两个语言的补的并的补就是交, 或者将两个 NFA 的状态求笛卡尔积, 得到并的状态转移, 两个状态都是接受状态才接受.

正则表达式: $+$ 是并, $\cdot$ 是连接, $^*$ 是闭包, $\epsilon$ 是空串, $\emptyset$ 是空语言. 正则表达式等价当且仅当它们的正则语言相等. 考虑原语 (单字符, 空串, 空语言) 的语言, 将 $+$, $\cdot$, $^*$ 变成语言的并, 连接, 闭包, 即可对任意正则表达式构造对应的正则语言. 将正则语言的自动机转成有且仅有一个接受状态的 NFA, 然后用正则表达式代替转移边 ($+$ 代替逗号), 然后缩点 (环路就是星号, 路径就是连接, 多条边就是并), 最后只剩两个点, q0 和 qf, 各自有表达式分别是 r1, r4 的自环, 正向边 r2, 反向边 r3, 则最终表达式为 $r1^*r2(r4+r3r1^*r2)^*$.

## 上下文无关语言

是正则语言的超集. 可以由上下文无关文法或下推自动机描述.

回文, 合法的括号序列都是上下文无关语言.

## 泵引理

基于鸽巢原理, 证明某语言不是正则语言的常用方法.

对于一个无限正则语言 L, 构造一个 DFA, 有 p 个状态. 取一个串 w, 满足 $|w| \geq p$, 得到它在 DFA 上的路径. 路径上应当有 $|w| + 1 > p$ 个 状态, 由于鸽巢原理, 有一个或以上的状态出现一次以上.

将 $w$ 分为三段 $xyz$, 其中 $xy$ 到达的状态是首个重复状态的第二次出现, $x$ 到达的是首个重复状态的第一次出现, $z$ 是剩余部分. 显然 $|y| \geq 1$, 而且 $xy$ 到达的状态中有 $|xy|$ 个独立状态, 因此 $|xy| \leq p$. 根据 DFA 的定义, $xy^iz \in L,  i \in N$. 

泵引理: 任意无限正则语言 L, 存在一个整数 p, 对任意字符串 $w \in L$, 如果 $|w| \geq p$, 则存在 $w = xyz$, $|y| \geq 1$, $|xy| \leq p$, 满足: $xy^iz \in L,  i \in N$.

有限语言一定是正则语言. 非正则语言一定无限. 证明某语言非正则时, 假设它是正则的, 如果泵引理不成立, 则矛盾, 该语言非正则.

但是, 泵引理只是无限正则语言的必要条件, 不是充分条件. 

# 文法

$G=(V, T, S, P)$, 有变量集合 $V$, 终结符集合 $T$, 起始符号 $S$, 产生式集合 $P$. 产生式形式为: 变量 $\rightarrow$ 句子. 包含终结符和变量的句子是句型, 句型可以派生 $\Rightarrow$ 出句子, 多次派生可以省略中间步骤以 $\xRightarrow{*}$ 表示. 由起始符号派生出的所有终结符串的集合即为文法对应的语言.

一个变量对应多个产生式时, 可用 $|$ 分隔不同句子.

## 线性文法

所有产生式的句子最多有一个变量.

左/右线性文法: 变量在左/右侧.

## 正则文法

生成正则语言的文法. 任意左/右线性文法.

设 G 是右线性文法, 构造 NFA: 每个变量对应一个状态, 起始状态对应起始变量, 另加一个新建的接受状态. 每个产生式, 如果句子是单个变量, 则连接 $\epsilon$ 边; 如果句子不含变量, 则根据终结符数量增加中间状态, 按顺序连接终结符边, 结束于接受状态; 如果句子是终结符加变量, 则先根据终结符数量增加中间状态, 按顺序连接终结符边, 结束于变量对应状态. 这样构造的 NFA 接受的语言和 G 生成的语言相同.

如果 G 是左线性文法, 则构造右线性文法 G', 使得 $L(G) = L(G')^R$. G' 只需将所有产生式的句子反转即可. 然后再将 G' 转成 NFA. 再将 NFA 做反转. 因此所有正则文法的语言都是正则语言.

接下来证明所有正则语言都能用正则文法描述. 先建立语言的 NFA, 然后为每个状态建立一个变量. 起始状态对应起始变量. 每个转移边都是一个产生式, 如果边是字符, 则产生式的句子是该字符加目标状态对应变量; 如果边是 $\epsilon$, 则句子是目标状态对应变量. 最后给每个接受状态对应变量增加一个产生式, 句子是空串 $\epsilon$. 因此所有正则语言都能用正则文法描述.

## 上下文无关文法

生成上下文无关语言.

最左/最右推导: 每次替换最左/最右侧的变量.

# P, NP, NP-Hard, NP-Complete

P(Polynomial): 多项式时间可解问题的集合.

NP(Non-deterministic Polynomial): 多项式时间可验证问题的集合.

NPC(NP-Complete): NP 中的最难问题, 多项式时间归约到其他 NPC 问题. (被认为指数时间可解, 一旦某个 NPC 有多项式时间算法, 则 P = NPC)



图同构: $n^{\log n}$.

整数分解: 亚指数时间.

哈密顿路: 尚无多项式时间算法. 

## SAT



## NPC

数独, 扫雷, 俄罗斯方块.

- 集合覆盖
集合的集合 $S$ 的所有元素并成全集 $U$. 判断 $S$ 是否存在 $k$ 大小的子集, 其并等于 $U$.

- 子集和
给定整数集合 $S$ 和整数 $t$, 判断是否存在 $S$ 的子集, 其和为 $t$.

- 划分
给定整数集合 $S$, 判断是否存在 $S$ 的子集 $S_1$, 使得 $S - S_1$ 的和等于 $S_1$ 的和. 其实就是子集和的特例 $t = \frac{\sum S}{2}$.

- 背包
$n$ 个物品, 每个物品有重量 $w_i$ 和价值 $v_i$. 背包容量 $C$, 目标价至 $T$, 是否存在方案选择物品集合, 使得总重量不超过 $C$ 且总价值至少为 $T$.

- 装箱
$n$ 个物品, 每个物品有体积, 每个箱子容量 $B$, 问是否能用 $k$ 个箱子装下所有物品.

- 斯坦纳树

- 图染色

- 独立集

- 支配集

- 最长路

- 旅行商

- 最大割

- 并行机器调度



