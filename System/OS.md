[TOC]

# 绪论

人工操作: 计算机速度越来越快

批处理: CPU 速度提高比 IO 设备快

分时系统: 多用户共享单个计算机, 划分时间片, 轮流分给用户

实时系统: deadline 内完成处理 (分为软硬实时系统)

## 概念

执行系统: 调度作业, 控制 IO 的软件

联机批处理: IO 由 CPU 处理

脱机批处理: IO 由卫星机处理

## 操作系统的特点

并发: 同一时间间隔内发生, 只要程序段执行时间存在重叠, 哪怕很小, 也算并发.

并行: 同一时刻发生, 并行一定并发

共享: 资源被并发进程共享, 时分复用(CPU), 空分复用(内存)

虚拟: 物理实体变为逻辑上的对应物, 逻辑物理转换是 OS 的重要任务

不确定(异步): 作业执行时间, 顺序不确定.

# 物质基础

DMA(直接内存访问): 绕过 CPU 直接内存访问, 外设直接与内存交换数据, 减少 CPU 负担. 需要地址连续, 占用总线, 需要中断支持.

## 特权级

高级状态(管态)可使用全部指令, 使用全部资源. 用户态禁止使用特权指令, 只允许访问自己的存储区域.

特权指令: IO, MMIO 地址空间访问, MSR(机器状态寄存器) 修改指令, 修改 PSW, 开关中断, 设置时钟, 停机, 任务创建和切换, 检测用户权限, 清内存(改变主存保护寄存器)

RISC-V: U, S, M 三个特权级

80386: 4 个特权级, 0 Kernel, 1,2 Device drivers, 3 Applications

## 中断

本质是受保护 (硬件实现, 过程中不可能被用户干预) 的状态切换.

程序非法操作, 系统干预; 系统调用; 接受响应外部事件

中断进入: 硬件实现, 改变机器状态

中断处理: 系统软件实现, 保护现场 (寄存器内容), 在高优先级处理

中断返回: 调用返回指令, 恢复现场, 硬件实现

中断类型: 异常 (exception), 中断请求 (interrupt request, IRQ), 系统调用/陷阱 (syscall/trap)

异常一般是同步的, 由当前执行代码引起的, 返回引起异常的指令; IRQ 一般是异步的, 来自外部, 返回离开时下一条指令; 系统调用是同步的, 同样返回下一条指令.

中断向量: 中断处理程序入口地址, CPU 状态字

## 时钟

PIT(可编程间隔定时器): 分单次模式和周期模式, 高精度PIT称为 HPET

RTC(实时时钟): 断电后仍保存时间, 通过主板电池供电, 通常与 CMOS RAM 集成, 也称 CMOS Timer

TSC(时间戳计数器): CPU 内部寄存器, 提供更准确的时间度量


# 结构

中断管理, 进程管理, 进程调度, 内存管理, 文件系统, 设备管理

## 分类

单一大内核: Linux. 系统结构简单, 内核庞大易崩溃

微内核: MACH, GNU HURD, QNX, 鸿蒙. 外围组件放用户态, 内核小容易稳定运行, IPC 通讯效率低

伴生内核: PKE实验, Docker, 云虚拟机. 运行多个 OS, 主 OS 和伴生 OS, 伴生结构简单, 但是整体系统复杂.

## 虚拟机

单个硬件抽象成不同的逻辑部件. 目的是并行执行的时候, 可以让不同的进程共享相同的硬件, 给进程一种 "独占处理器和内存" 的幻觉.

> All problems in computer science can be solved by another level of indirection.
>                           —— David Wheeler

ISA(指令集)虚拟机: 在指定 ISA 上模拟另一套 ISA. (spike)

OS(操作系统)虚拟机: 在 A 操作系统上模拟 B 操作系统. (vmware, docker)

API(库函数)虚拟机: 模拟 OS 的各类用户态 API. (Wine)

语言虚拟机: 虚拟语言运行时环境 (Java 虚拟机)

## 启动和生成

- x86 Linux 启动
开电源-BIOS(自检, PCIe枚举, 处理器进入实模式, 加载启动盘 MBR, 跳转到 MBR)-MBR(读 Linux 内核到内存, 跳转到 kernel 入口)-Kernel(进入保护模式; 设置分段, 中断处理, 时钟中断; 构造页表; 创建进程池)

- RISC-V64 PKE 启动
spike模拟RV机器(模拟硬件信息填入 DTS, 加载内核到内存, 跳转到内核入口)-PKE内核(通过 DTS 设置 HTIF 获取内存信息, 加载执行环境, 加载应用)

DTS: 设备树源码文件

生成: 将 OS 安装到启动装置

启动环境: Bootloader, OS内核, 文件系统, 执行环境

## 程序

生成: 编译(.c - .o), 链接(.o - .exe)

静态链接: 将编译的内容和库编译到同一个二进制文件中. 不依赖函数库. 但是会造成冗余 (重复保存轮子).

动态链接: 运行时再合并. 引用外部函数, 运行时需要寻找并加载库.

用户界面: 操作界面 (命令接口, 使用命令行或 GUI 组织工作), 系统功能服务界面 (用户程序运行过程中通过 syscall 请求系统服务)

汇编程序显式调用访管指令, 高级语言隐式调用访管指令.

系统调用实现: 和调用号,执行程序一一对应; 有参数和返回值; 系统有一个入口地址表.

使用 API 减少系统调用, 因为系统调用开销大 (特权级切换, 上下文切换). 通过库函数封装系统调用, 使用缓存减少调用次数.

# 进程

顺序程序: 顺序性(严格按顺序执行指令), 封闭性(结果不受外界因素影响), 可再现性(结果与时间无关, 只与初始条件有关)

先后次序图: 运行过程相当于从图上 BFS.

多道运行: 宏观并发, 微观串行

并发让程序失去封闭性和可再现性(共享变量, 则结果依赖于相对速度), 一个程序可对应多个计算(跑好多次), 相互制约(共享资源和变量)

进程: 一个程序在给定活动空间和初始环境下，在一个处理机上的执行过程

## PCB(进程控制块)

进程由 PCB 和程序和数据构成. 记录进程与其他进程、系统资源的关系以及进程在各个不同时期所处的状态的数据结构. 

包含进程名或 pid, 进程状态, 队列指针(同一状态下一进程 PCB), 进程优先级, CPU 现场保护区(寄存器内容), 通信信息(进程间通信), 家族联系, 占有资源清单.

进程控制: 状态变化.

## 进程控制原语

创建: create (name，priority) 创建进程, 构造 PCB

撤销: kill/exit 将 PCB 结构归还 PCB 池, 资源归还父进程, 从 PCB 总链删除, 转到进程调度程序.

等待: susp(chan) 中止执行, 加入到等待 chan 的队列中, 转到进程调度程序.

唤醒: wakeup(chan) 将等待 chan 的队列中第一个进程移到就绪队列, 改变状态为就绪.

## 互斥

临界资源: 一次仅允许一个进程使用

临界区: 进程中对公共变量 (或存储区)进行审查与修改的程序段. (比如对应变量 x 的临界区是 x += 1)

互斥: 一个进程访问临界资源时不允许其他进程访问.

## 锁和信号灯

同步: 进程在关键点互相等待互通消息

锁: 表示资源状态的变量 w

上锁: 检测 w, 是 1 等待, 是 0 置 1.

开锁: 置 w 为 0.

信号灯: (s,q), s 表示资源数目, q 表示等待队列. $s \geq 0$ 时绿灯; $s < 0$ 时红灯.

P: s -= 1, 如果操作后 s < 0, 则进程加入等待队列 q, 转到进程调度程序. 否则继续执行.

V: s += 1, 如果操作后 s <= 0, 则从等待队列 q 中取出一个进程, 放入就绪队列.

s 表示资源减去请求. V 释放. s >= 0 时队列为空. s < 0 时队列非空, s = -队列长度 = 资源总数(正在占用的资源) - 请求资源数.

## 进程流图

圆点 s 启动, f 结束. 箭头表示进程, 箭头的终点表示进程同步.

## 程序描述

大约是 c 的语法, cobegin 是并发开始, coend 是并发结束.

```c
main() {
  int mutex=1;       // 互斥信号灯
  cobegin
    pa();
    pb();
  coend
}
pa(){
  p(mutex);
  csa;
  v(mutex);
}
```

## 生产者-消费者

生产者: 生产数据放入缓冲区

消费者: 从缓冲区取数据进行处理

两个同步信号灯 $S_a$, $S_b$ 表示空位和数据数量, 一个互斥信号灯表示缓冲区占用.

生产者: $p(S_a)$, $p(mutex)$, 生产数据, $v(mutex)$, $v(S_b)$.

消费者: $p(S_b)$, $p(mutex)$, 消费数据, $v(mutex)$, $v(S_a)$.

## 读者-写者

可以同时读, 不能同时写.

读者优先: 两个锁: counter 互斥 rmutex 和读写互斥 rwmutex. 读者计数器 counter, 读者第一个进来时上读写锁, 最后一个读者离开时释放读写锁. 问题是如果有大量读者, 读写锁持续被读者占用, 写者可能饿死.

写者优先: 存在写需求时, 后续读者等待. 三个锁: counter 互斥 rmutex, 在读互斥 nrmutex, 读写互斥 rwmutex. 写者上 rwmutex 锁时, 如果有读者在读, 等待 nrmutex, 此时新读者等待 rwmutex, 因此无法开始读. 当前所有读者读完后, 释放 nrmutex, 写者开始写. 没有写需求时, rwmutex 空闲, 新的读者可以上 rwmutex 锁, 并且上 nrmutex 锁, 紧接着释放 rwmutex 锁, 允许其他读者和写着进入竞争.

## 通信

进程间以较高效率传递较多数据.

消息缓存通信: 明确协议和消息格式. 包括消息缓冲, 发送/接受原语.

信箱通信: 信箱可以在用户空间或内核空间.

## 线程

上下文切换, 进程创建, 缓存刷新等开销大.

线程是进程中的执行路径, 有自己的栈, 和父进程共享主存. 开销比进程小得多. 由于线程共享内存, 通信方便.

## 系统并发

fork() 创建一个父进程副本, 对父进程返回子进程 pid, 对子进程返回 0.

execlp(“max”,15,18,10,0); 或 execvp(“max”,argp); 更换进程代码 (代码段和数据段)

使用 pthread 创建管理线程.

wait(stat); 等待一个子进程结束, 返回子进程 pid, stat 指针存放退出码. waitpid(pid, stat, options); 等待指定 pid 的子进程结束.

多进程的全局变量也是隔离的, 多线程共享, 但是需要注意互斥.

## IPC

进程间通信 (Inter-Process Communication)

system v IPC: 消息队列(msg/message queue), 共享内存(shm/shared memory), 信号量(sem/semaphore set)

shell 命令: ipcs 查看 IPC 资源, ipcrm 删除 IPC 资源.

分配 ipc 对象, 获得对 ipc 对象的访问: ~get

IPC 操作: 发送msg: msgsnd; 接受msg: msgrcv, 信号量操作: semop; 共享内存映射: shmat; 解除映射: shmdt

IPC 控制: ~ctl

信号量: semget(key, nsems, flags) 创建信号数组. semctl(id, semnum, cmd, ...) semnum 是下标, 表示对 id 信号数组的第 semnum 个信号进行操作 (如 SETVAL, IPC_RMID). semop(id, sops, nsops) 对信号数组 id 进行 nsops 个信号操作, sops 是 struct sembuf 数组指针. P/V 操作可以通过调用 semop 实现.

共享内存: shmget(key, size, flags) 创建共享内存块, 返回 id. shmat(id, addr, flags) 映射到进程地址空间, 返回映射地址. shmdt(addr) 解除映射. shmctl(id, cmd, buf) 控制共享内存块 (如 IPC_RMID 删除).

# 资源

静态分配: 作业到达时分配资源, 运行结束释放资源.

动态分配: 作业运行过程中按需分配和释放资源.

物理资源和虚拟资源之间由系统进行映射. CPU 通过进程调度映射到进程, 主存通过地址映射映射到虚拟内存, 外部设备通过设备分配动态映射到虚拟设备, 文件物理结构通过磁盘空间分配和文件目录查找映射到文件逻辑结构

资源描述器: 描述资源最小分配单位的数据结构. 包括资源名, 最小分配单位大小, 地址, 分配标志, 链接信息, 存取权限, 密级, 存取时间, 资源状态, 资源类型, 资源数量.

资源信息块: 描述某类资源的请求者队列, 可用资源队列和分配程序.

分配策略: 先请求先服务, 优先调度, 针对设备特性调度(磁盘磁带).

## 死锁

在两个或多个并发进程中，如果每个进程持有某种资源而又都等待着别的进程释放它或它们现在保持着的资源，否则就不能向前推进。此时，称这一组进程产生了死锁。

死锁必要条件: 互斥条件(临界资源), 不剥夺条件(未使用完毕的资源无法被夺走), 部分分配(申请部分资源, 在等待新资源的同时, 继续占用已经分配到的资源), 环路条件(存在循环链, 每个进程已获得的资源同时被下一个进程请求).

- 预防: 思想是破坏必要条件.

破坏互斥: 临界资源转化为共享资源, 不是所有资源都可共享;

破坏不剥夺: 申请者不被满足则释放所有资源/占用者的资源被申请时由系统剥夺, 实现复杂, 可能导致活锁;

破坏请求和保持: 静态分配. 简单但是资源利用率低.

破坏循环等待: 有序分配, 按编号顺序请求. 用户编程麻烦, 利用率低.

- 避免: 分配时判断, 确保不会死锁才分配. 提高利用率, 每次分配都需计算.

初始状态: 进程集合 p/资源集合 r/资源矢量 w

运行状态: 请求矩阵 d/分配矩阵 a/需求矩阵 m = d + a

安全状态: 至少有一种分配顺序能不造成死锁. 存在一个进程的顺序, 使得每个进程的请求都能被当前资源和前面进程释放的资源满足.

定义 Work = w - $\Sigma$ a, Finish = [false].

取 i, 满足 Finish[i] == false 且 d[i] $\leq$ Work[i]. 修改: Work[i] += a[i], Finish[i] = true. 重复直到找不到满足条件的 i.

银行家算法: 申请者事先说明 m[i], 申请时系统审查是否仍在安全状态, 是则分配, 否则等待.

- 解除: 检测并解除.

检测: 进程作点, 请求作边, 如果通过剩余资源可以满足需求, 则释放资源, 如果最终可以消除所有边, 则图可完全简化, 一定无死锁; 否则剩下边的点就是死锁状态的进程.

解除: 资源剥夺: 挂起进程, 抢占资源, 需防止挂起进程饥饿; 撤销进程, 剥夺资源, 实现简单, 代价可能很大; 进程回退: 让一个或多个进程回退到足以避免死锁的地步, 要求系统记录还原点. 

# 处理机调度

宏观作业调度, 微观进程调度.

## 作业调度

从后备到执行和从执行到完成.

作业控制块(JCB): 记录系统作业情况(类型, 状态, 资源请求和分配).

调度算法需要考虑很多因素, 面向用户: 周转时间, 响应时间, 截止时间; 面向系统: CPU 利用率, 吞吐量, 设备的均衡利用; 面向算法考虑易于实现, 执行开销.

周转时间是作业从提交给计算机到结果返回用户的时间, 带权周转时间是周转时间和运行时间比值.

先来先服务(FCFS): 每次选等最久的. 实现简单, 效率较低.

短作业优先(SJF): 每次选估计运行时间最短的. 易实现, 吞吐量高, 不考虑长作业利益.

相应比高者优先(SHRN): 每次选响应比 (1 + 等待时间/执行时间) 最高的. 浮点运算对早期计算机开销大.

优先数调度(PS): 综合考虑等待时间, 运行时间, 缓急程度, 资源使用, 每个作业设优先数, 每次选优先数最高的. 综合考虑的算法困难.

均衡调度(ED): 更理想化. 更难实现, 开销可能比调度提升的效率还大.

## 进程调度

调度和分派两个功能. 调度是组织和维护就绪进程队列; 分派是当处理机空闲时, 从就绪队列队首中移一个 PCB, 并将该进程投入运行.

进程调度需要记录保持所有进程有关情况和状态, 决定分配处理机策略, 实现处理机分配和回收.

非剥夺式: 实现简单, 开销小, 难以满足紧急任务要求; 剥夺式: 相应紧急任务快, 增加开销.

- 进程优先数
分为静态/动态优先数. 静态优先数又分系统确定(考虑运行时间, 资源, 类型), 用户确定(考虑紧迫程度), 结合确定; 运行过程中根据系统设计目标, 调整进程优先数.

- 循环轮转
系统响应时间分成时间片, 每个进程占用一个时间片, 用完后让出, 循环轮转. 存在简单循环轮转 (时间片等大); 可变时间片轮转调度.

- 多级反馈
多个简单算法综合和发展.
三个队列: IO等待队列, 低/高就绪队列. 请求 IO 时进入 IO 等待队列, IO 完成后进入高就绪队列; 时间片用完进入低就绪队列; 高就绪队列空闲时调度低就绪队列.
优先照顾短作业和 IO 密集型作业, 适当照顾长作业.

# 内存

CPU 可直接访问寄存器和主存, 访问速度寄存器 > 主存 >> 赋存(外存).

虚拟化: 复用 CPU, 复用内存, 复用磁盘或外部设备(不成熟)

需求: 进程需要内存, 进程间需要内存隔离. 可能面对比物理内存更大的内存需求, 可能存在进程访问越界地址, 可能动态分配内存.

段(大小不等)页(大小相等)式存储.

## 主存管理

- 映射

地址映射: 从逻辑地址变换成物理地址. 编译时确定(不能浮动), 装入时确定(静态地址映射), 运行时确定(动态地址映射).

MMU: 内存管理单元, 硬件设备, 实现地址映射.

- 分配

主存资源信息块: 描述主存使用情况的数据结构. 包括主存总量, 可用主存量, 分配算法, 空闲分区链表.

分配/放置/调入/淘汰策略

- 扩充: 主存和辅存都可以被映射到逻辑空间.

- 保护: 界地址保护(禁止进程访问出界), 存储键保护.

## 分区

动态建立分区, 动态重定位.

主存资源信息块(M_RIB): 等待/空闲队列头指针, 分配程序入口

分区描述器(PD): Flag(0空闲, 1占用), 分区大小, 链接指针(下一个空闲区). 集中存储或分散存储.

分配时寻找空闲块, 等于请求大小就直接从空闲队列中摘除, 否则分割. 回收时若相邻分区空闲则合并, 否则新建空闲区并加入队列.

首次匹配(取第一个能装入的地址最低的空闲块), 最佳匹配(放到大小最接近的空闲区种), 最差匹配(放到最大的空闲区)

已分配区之间存在碎片, 移动已分配区信息, 使本来分散的空闲区连成一片.

## 页

页, 大小相等, 逻辑虚页, 物理实页(主存块). 页表记录映射关系, 存于主存, 使用高速缓冲缓存.

每个程序逻辑地址独立, 有各自的页表, 由 PTBR 指示位置, 由 PRLR 指示大小, 映射到共享的物理地址空间. 页号就是逻辑地址去掉偏移后的部分, 通过页号在页表找到表项, 得到物理块号, 得到物理地址. 两次访存.

联想存储器(缓冲): 存储当前页号和块号, 又称快表(TLB). EAT(有效地址转换时间) = $\alpha * (t + \epsilon) + (1 - \alpha) * (2t + \epsilon) = \epsilon + 2t - \alpha t$.

简单页式系统: 装入全部页面

请求页式系统: 装入部分页面, 需要保存中断位(1在主存, 0不在, 如果不在, 记录辅存地址), 缺页时有空闲块调入页面, 否则淘汰原来的页.

淘汰策略: 加入引用位和改变位. 避免颠簸, 减少缺页中断率.

- 最佳算法(OPT): 淘汰后续最长时间不被访问的页. 理想化, 需要预知未来.

- 先进先出(FIFO): 淘汰最早进入内存的页, 主存中块内存指针, 指向下一个被调入的块. 简单, 可能淘汰经常使用的页.

- 最久未使用(LRU): 淘汰最长时间未被访问的页, 访问页面时引用为置 1, 计时. 近似 OPT, 精确实现复杂(硬件实现计数器, 软件实现页号栈).

- 近似淘汰(NRU): 定期清除引用位, 选择首次发现的引用位为 0 的页, 实现方式: 判断替换指针指向的块的下一个块, 如果引用位为 0, 淘汰; 否则置 0, 跳到下一个块. 简单, 效率低.

## 段

程序中逻辑意义完整的信息集合. 段的逻辑地址连续. 段式地址的高位是段号, 低位是偏移. 存在段表, 记录段号到物理块号的映射关系. 现代系统多采用段页式管理, 即在段内分页.

每次访存最多访问三次: 段表, 段内页表, 主存块.

# 设备

存储/输入输出/通信设备

目标: 提高利用率, 合理分配, 提高并行性; 方便用户, 统一界面, 与物理设备隔离.

功能: 状态跟踪; 分配和回收; 设备控制.

设备控制块: 设备名/属性/命令转换表指针/IO总线上的地址/状态/当前用户进程指针/请求队列指针.

## 独立性

用户仅需知道逻辑设备名, 逻辑设备名/号是可变可设置的, 物理设备名是固定的.

一个程序被分配某类设备中任意一台都能正确执行; 程序尽可能与设备类型无关. 

- 高级语言中通过软通道实现, 指派逻辑设备名.

- 批处理系统中, 用联接说明语句来定义

- 交互系统中, 用指派命令来定义

优点: 方便用户, 改善利用率, 提高可扩展性可适应性

## 缓冲

不同速度的设备之间传输信息时平滑传输过程的常用手段, 通过缓冲器或软件缓冲实现. 缓冲可以协调速度差异, 数据单元大小差异, 拷贝正确语义 (防止拷贝过程中数据被修改).

双缓冲: 两个缓冲区, 交替进行, 理想情况下进程和设备都不等待.

UNIX 的磁盘缓冲: 读预先缓存, 写延迟发送. 可以加快响应, 减少 IO 次数, 增强吞吐量.

缓存首部: 设备号, 块号, 状态标志(忙BUSY, 有效AVE, 延迟写DELWR, 正在写WRITE, 正在读READ, 存在进程等待空闲WAIT), 数据区域指针, 链接指针(设备/空闲缓冲区队列前后指针), 字节数, 返回的出错信息.

缓存中的两个链: b 链 (和某类设备有关的所有缓冲区) 和 av 链 (可重新分配的缓冲区), 都是环状双向链表.

BUSY 从缓冲区被分配(需要), 到读写结束, 这段时间置 1.

需要空闲 buf 取队首, 新空闲 buf 加入队尾. 如果重分配的 buf 有延迟写标记, 则执行写, 然后分配.

## 共享

独享设备是临界资源, 系统执行独享分配.

共享设备可由多作业多进程同时使用, 系统执行共享分配.

可以通过虚拟技术, 将独享设备虚拟化成共享设备. 通常把代替独占设备的外存空间称为虚拟设备. 系统分配磁盘空间, 建立相应数据结构.

SPOOLING: 预输入(数据预先读入辅存输入井), 缓输出(数据写入辅存输出井). SPOOLING 系统提供输入收存和输出发送工作, 由通道完成输入输出, 使外部设备可并行. 优点是提供虚拟设备, 外围设备同时联机操作, 加快处理速度. 需要大辅存来开输入输出井, 硬件上需要通道装置和中断系统, 需要实现预输入/缓输出表, 需要输入/缓输出/井管理程序.

## IO控制

CPU - IO控制器 - 物理设备

控制方式: 循环测试I/O方式, I/O中断方式, DMA方式, 通道方式.

IO 子系统: 在内核和 IO 设备之间, 为应用层提供接口. 设备的差别被 IO 子系统内核 (设备驱动程序) 封装, 提供标准接口. 驱动程序可以将 IO 子系统和硬件分离, 简化了操作系统.

设备处理程序能直接控制设备运转, 每一类设备有专门的设备处理程序, 控制同类多台设备同时工作.

控制方式可以通过每一类设备一个设备处理进程, 有 IO 请求进程被唤醒, 否则休眠; 或者将设备当作文件, 用文件系统命令读写. 

IO 过程: 系统调用 doio(ldev,mode,amount,addr);. 根据逻辑设备描述器, 将逻辑设备 ldev 转换为物理设备 pdev; 根据 DCB 允许的操作, 检查 mode 合法性; 根据参数形成请求块 (IORB), 挂载到请求队列.

用户进程-(系统调用) IO过程-(IORB 入队, 唤醒 IO 处理进程)IO处理进程-控制 IO 设备-(同步)IO处理进程-(同步用户进程)

# 文件系统

文件是在逻辑上具有完整意义的信息 (信息/数据项或记录) 集合, 它有一个名字以供标识, 文件名是以字母开头的字母数字串.

应用不应当将文件存在进程地址空间. 文件需要支持并发访问, 需要存活于进程生命周期之外, 可以很大. 文件由操作系统管理.

系统/程序库/用户文件, 不保护/执行/只读/读写文件, 输入/输出/输入输出文件.

用户使用文件符号名, 系统使用文件内部标识; 文件扩展表示文件使用特征; 文件属性表示文件类别, 保护等级等.

文件系统是操作系统管理存取文件信息的软件机构, 由数据结构, 管理程序, 一组操作构成. 用户可以按名存取, 系统可以管理辅存空间, 管理文件集合, 保护文件. 文件系统使用简单, 安全可靠, 既能共享, 又能保密.

## 文件结构

文件可能顺序存取也可能随机存取.

逻辑结构是用户看到的, 物理结构是实际在辅存上的存储方式. 逻辑记录是文件中按信息逻辑上的独立含义划分的信息单位, 物理记录是存储介质上由连续信息组成的区域, 也叫块.

流式文件无结构, 是有序字符的集合. 按信息个数或以特殊字符为界存取. 记录式文件在逻辑上是一组连续顺序的记录的集合. 记录可以定长或变长.

多数文件都很小, 少数文件很大. 常用物理结构有: 连续文件(数组. 创建时就确定大小, 不轻易改变, 存储空间利用率不高, 结构简单实现容易, 连续存储时较快), 串联文件(链表, 较好利用空间, 不必事先知道长度, 易于修改扩充, 连续存取较快, 链接字占空间易出错), 文件映照技术(FAT, 设置 FAT 表, 每个盘块有一个表项, 集中存放文件各物理块指针, 文件目录只存首块指针), 索引文件(逻辑块号与物理块号通过索引表映射, 文件目录保存索引表指针, 在索引表依次访问物理块, 可能存在多级索引, 索引表和数据共同组成索引文件, 易于增删, 直接读写任意记录, 无碎片, 索引表带来时空开销).

## 目录

记录文件名, 地址及其说明信息 (逻辑结构, 物理结构, 类型), 控制信息(权限, 管理信息).

一级文件目录: 所有文件信息在一张表. 按名存取, 实现简单, 文件多时检索时间长, 要求文件名和文件一一对应, 不能重名或硬链接.

树形文件目录: 目录项可以描述文件或子目录, 数据文件一定在叶. 由根目录开始, 经过若干子目录到达文件的所有目录文件符号名和文件符号名, 中间用分隔符隔开, 得到文件路径名. 文件名相同, 只要路径名不同即可区分. 

## UNIX 文件系统

树形目录结构, 可装卸文件系统, 文件是流式文件, 外部设备视同文件.

文件分为普通文件, 目录文件, 特别文件(块设备文件, 字符设备文件, 每种 IO 设备都有一个特别文件, 是 IO 的通道, 用户与硬件关联的桥梁).

文件索引节点(indexnode): 存储目录信息中除了名字外的信息, 包含所有者标识, 文件类型, 存取许可权, 连结数目(被几个文件名指向), 地址索引表. 目录项中只有文件名和 inode 编号.

- UNIX 第七版文件索引结构
索引表 i_addr[] 有 8 个指针项, 小文件直接使用前 8 个指针, 大小 $8 * 512B = 4KB$. 大文件 i_addr[] 是一级间接索引, 使用前 7 位, 文件大小 $7 * 256 * 512B = 896KB$. 巨型文件使用 i_addr[7] 指向二级索引表, 前 7 位仍然是一级间接索引, 文件大小 $896KB + 256 * 256 * 512B = 32MB + 896KB = 32.875MB$.

- UNIX system V 文件索引结构
索引表 i_addr[] 有 13 个指针项, 前 10 项是直接索引, 文件大小 $10 * 512B = 5KB$. 第 11 项是一级间接索引, 增加 $256 * 512B = 128KB$. 第 12 项是二级间接索引, 增加 $256 * 256 * 512B = 32MB$. 第 13 项是三级间接索引, 增加 $256 * 256 * 256 * 512B = 8GB$. 

目录文件: 目录表, 由目录项 (老版本为 16 字节, 前两字节是 inode 号, 后 14 字节为文件名) 组成. 一个块存放 $512/16 = 32$ 个目录项.

每个文件系统有根目录, 根目录 inode 是设备索引区第一个. 打开文件时, 通过根目录 inode 得到根目录文件每块, 根据路径名逐级查找子目录, 最后找到文件 inode, 得到每块, 读写文件.

文件勾链: 一个文件由多个目录项指向. UNIX 只允许指向普通文件的勾链. 

开关文件: 为了提高系统效率, 减少内存占用, 通过打开文件机构管理文件开关. 包含了活动 inode 表, 打开文件表, 用户文件描述符表. 文件打开时, 文件相关 inode 拷贝到主存, 形成活动 inode 表项, 包含文件属性, 链接与引用信息, 锁与状态; 系统记录打开文件表, 包含读写标志, 引用计数, inode 指针, 读写位置指针; 用户进程控制块中存在数组 u_ofile, 用户文件描述符表, 每个元素指向系统打开文件表项, u_ofile 下标就是文件描述符 fd. 进程可以打开不同文件或用不同方式打开同一文件.

u_ofile - 系统打开文件表 - 活动 inode 表

## 空间管理

位视图(0闲1满, 空间小, 可保存在 RAM)或空闲块链.

UNIX 使用文件卷, 每个逻辑设备(文件系统)占用一片连续空间存文件卷, 包含引导块(一个块, 包含引导程序), 管理块(记录文件系统数据, 如大小, 空闲块数), 索引节点区(存 inode), 然后存储数据块(存文件数据和目录).

UNIX 成组链接空闲块, 结合空闲表和空闲链, 初始都是空闲的, 从后往前每 100 块 (最后一组 99 块) 分一组. 每组地址最高的一块为索引, 记录下一组 100 块的块号 s_free[100] 块数 s_nfree. 最前面一组的信息存在管理块. 其中 s_free[0] 指向下一组索引块号, 后面的位置地址从低到高存下一组的其它块, s_nfree 是下一组的块数.

分配时, 读管理块, 弹栈, 当分配到 s_free[0] 时, 也就是索引块, 先把索引块内容读入管理块. 回收时, 堆栈, 直到管理块有 100 块, 新的回收块写入管理块的索引, 然后清空管理块的栈, 压入新的这一块.

妙处在于, 当前正在分配的组的块直接由管理块指向, 并且分配. 这一组分配到最后一个块, 直接把下一组块的信息拷入管理块, 这样就把最后一个块腾出来分配给用户, 浪费了 0 块.

## 共享与安全

文件共享: 省空间, 进程间交换信息.

文件安全: 存取权限. 验证身份, 访问控制矩阵, 存取控制表, 用户权限表, 口令, 编解码.

当前目录: 当前用户使用的目录 pwd.

链接: 一个目录中的表项指向另一个目录表项的物理位置. (分硬链接和软链接/符号链接) 硬链接直接连到 inode, 不能跨文件系统; 软连接连到文件路径名, 可以跨文件系统, 但多一次查找开销.

## 操作

create, delete, rename, open, close, write, read.

备份: 周期性转储, 增量性转储. 动态备份, 远程备份.


